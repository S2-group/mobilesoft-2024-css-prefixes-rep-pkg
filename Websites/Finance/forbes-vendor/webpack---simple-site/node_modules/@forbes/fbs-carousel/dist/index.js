(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FbsCarousel"] = factory();
	else
		root["FbsCarousel"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hasWindow */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hasDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE; });
/* unused harmony export hasMatchmedia */
/* harmony export (immutable) */ __webpack_exports__["b"] = findCurrentConfiguration;
/* harmony export (immutable) */ __webpack_exports__["c"] = generateActiveConfiguration;
/* harmony export (immutable) */ __webpack_exports__["g"] = loopIndexOrder;
/* harmony export (immutable) */ __webpack_exports__["f"] = loopIndex;
/* harmony export (immutable) */ __webpack_exports__["d"] = getDistances;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__ = __webpack_require__(1);
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/**
 * Use this to stop erroring out on server (even if invalid isServerPrerender flag is sent)
 */
var hasWindow = typeof window !== 'undefined';
var hasDocument = typeof document !== 'undefined';
var FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE = 'data-fbs-carousel-config-id';
var EMPTY_BREAKPOINT = { breakpoints: [] };
/**
 * Who doesn't support matchmedia? Check for it regardless, but expect diminished functionality.
 */
var hasMatchmedia = hasWindow && !!window.matchMedia;
/**
 * Finds the current carousel configuration from all allowed locations
 *
 * If rendering on a client, look for configuration objects on the window object
 * First look for ID, then the special `data-fbs-carousel-config-id` attribute if not found
 * Config will be used if it exists on the window.FbsCarouselConfig object
 *
 * E.G.
 * `<fbs-carousel id="carousel-1"></fbs-carousel>`
 * would use the config from
 * `window.FbsCarouselConfig['carousel-1]: FbsCarouselConfig` configuration object
 *
 * while
 * `<fbs-carousel data-fbs-carousel-config-id="carousel-2"></fbs-carousel>`
 * would use the config from
 * `window.FbsCarouselConfig['carousel-2]: FbsCarouselConfig` configuration object
 * @param config Configuration value passed to carousel initialization. If present, supercedes all others.
 * @param el Parent element of fbs-carousel or fbs-slider.
 */
function findCurrentConfiguration(config, el) {
    /**
     * Performs housekeeping for storing unmodified, unflattened configuration values for server prerender
     * @param config Current unflattened configuration
     * @returns Current active unflattened configuration minus server prerender values
     */
    var cb = function (config) {
        var _config = __assign({}, config);
        delete _config.serverDomEngine;
        delete _config.isServerPrerender;
        return _config;
    };
    // If a config was passed to the carousel initialization, use it.
    if (config) {
        config.originalConfig = cb(config);
        return config;
    }
    // Looks for config on window objects otherwise
    var windowConfig;
    if (hasWindow) {
        if (el.id && (windowConfig = (window.FbsCarouselConfig || {})[el.id])) {
            // Inline assignment because it's long
        }
        else {
            var attribute = el.getAttribute(FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE);
            windowConfig = attribute && (window.FbsCarouselConfig || {})[attribute];
        }
    }
    if (windowConfig) {
        windowConfig.originalConfig = cb(windowConfig);
    }
    // If no allowable configuration was provided, just use the default
    return windowConfig || __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */];
}
/**
 * Recursively loops over the passed carousel configuration options to match provided breakpoints
 * and create a single flattened ruleset for the current window size
 *
 * @param config Global configuration object passed to FbsCarousel
 * @param bypassDefaults When true, doesn't combine current config rules with FBS_CAROUSEL_DEFAULTS
 */
function generateActiveConfiguration(config, bypassDefaults) {
    var _config = __assign({}, config);
    var cleanup = function () {
        _config.slidesToScroll = Math.min(_config.inView || 1, _config.slidesToScroll || 1);
        _config.currentOffset = Math.max(0, Math.min(_config.currentOffset, _config.inView - 1));
    };
    if (!bypassDefaults) {
        _config = __assign({}, __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */], config);
    }
    // Don't flatten the config object if it's rendering for server view -
    // Breakpoint data is required for inline styles
    // Additionally, allow graceful degredation for IE9- or other browsers that don't have css matchmedia support
    if (_config.isServerPrerender || !hasWindow || !hasMatchmedia) {
        // On server prerender, we need to know the *largest possible* number of slides to display
        // regardless of breakpoint registered. The easiest way is to just recursively check all breakpoints
        // and set the top level inView to the largest one found.
        if (_config.isServerPrerender) {
            var largestInView = _config.inView;
            var hasDisabledBreakpoint = _config.enabled === false;
            var breakpoints = (_config.breakpoints || []).slice(0);
            while (breakpoints.length) {
                var b = breakpoints.shift();
                hasDisabledBreakpoint = hasDisabledBreakpoint || b.config.enabled === false;
                if (b.config.inView > largestInView) {
                    largestInView = b.config.inView;
                }
            }
            _config.inView = largestInView;
            _config.hasDisabledBreakpoint = hasDisabledBreakpoint;
        }
        cleanup();
        return _config;
    }
    // Start flattening breakpoint specific rules
    if ((_config.breakpoints || []).length) {
        for (var i = 0; i < _config.breakpoints.length; i++) {
            var breakpoint = _config.breakpoints[i];
            // Only allow valid breakpoint definitions
            if (!breakpoint.breakpoint) {
                continue;
            }
            if (window.matchMedia(breakpoint.breakpoint.substr(7)).matches) {
                // Flatten current breakpoint level and check for matching children to flatten
                _config = generateActiveConfiguration(__assign({}, _config, EMPTY_BREAKPOINT, breakpoint.config), true);
                // Only flatten first matched rule per level
                break;
            }
        }
    }
    cleanup();
    return _config;
}
/**
 * Gets slide at specified index, looping around boundaries
 * E.G. array ['a', 'b', 'c'] with i `-1` returns 'c'
 * @param order Slide order object of carousel
 * @param i Index of slide to retrieve
 */
function loopIndexOrder(order, i) {
    return order[loopIndex(i, order.length)];
}
/**
 * Gets loop-adjusted index value after modifications
 * Ranges number between 0 inclusive and len, non inclusive
 * @param i Index to loop
 * @param len Maximum size of i
 */
function loopIndex(i, len) {
    while (i < len) {
        i += len;
    }
    return (len + i) % len;
}
/**
 * Calculates straight line distance between two points on a bidirectionally linked array
 * E. G. ['a', 'b', 'c', 'd', 'e'], using points 0 and 3 would take [2, 3]. 2 steps left, 3 steps right.
 * Straight line distance will always equal array.length
 * @param a First point
 * @param b Second point
 * @param len Length of source array
 */
function getDistances(a, b, len) {
    return a > b ? [a - b, len - a + b] : [len - b + a, b - a];
}


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FBS_CAROUSEL_DEFAULTS; });
var FBS_CAROUSEL_DEFAULTS = {
    currentOffset: 0,
    inView: 1,
    speed: 500,
    showControls: true,
    imagePreloadAttribute: 'data-bg-image',
    initialIndex: 0,
    isServerPrerender: false,
};


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SLIDE_WRAPPER_CLASS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return SLIDE_TRACK_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SLIDE_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CONTROL_WRAPPER_CLASS; });
/* unused harmony export CONTROL_DISABLED_WRAPPER_CLASS */
/* unused harmony export CONTROL_LEFT_CLASS */
/* unused harmony export CONTROL_RIGHT_CLASS */
/* unused harmony export CONTROL_DISABLED_CLASS */
/* unused harmony export SLIDER_INITIALIZED_CLASS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SLIDER_SLIDE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SLIDER_PRERENDER_STYLES; });
/* unused harmony export SLIDER_UNIQUE_ID */
/* harmony export (immutable) */ __webpack_exports__["g"] = initFromDom;
/* unused harmony export createControls */
/* unused harmony export createSlideNode */
/* harmony export (immutable) */ __webpack_exports__["f"] = generateSlideId;
/* unused harmony export toggleControls */
/* harmony export (immutable) */ __webpack_exports__["h"] = updateSlides;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__serverHelpers__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons__);
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var SLIDE_WRAPPER_CLASS = 'fbs-slider__slides-wrapper';
var SLIDE_TRACK_CLASS = 'fbs-slider__slides';
var SLIDE_CLASS = 'fbs-slider__slide';
var CONTROL_WRAPPER_CLASS = 'fbs-slider__controls';
var CONTROL_DISABLED_WRAPPER_CLASS = 'fbs-slider--no-controls';
var CONTROL_LEFT_CLASS = 'fbs-slider__control-left';
var CONTROL_RIGHT_CLASS = 'fbs-slider__control-right';
var CONTROL_DISABLED_CLASS = 'disabled';
var SLIDER_INITIALIZED_CLASS = 'fbs-slider--initialized';
var SLIDER_SLIDE_ID = 'data-fbs-carousel-slide-id';
var SLIDER_PRERENDER_STYLES = 'data-fbs-carousel-prerender-styles';
var SLIDER_UNIQUE_ID = 'data-fbs-carousel-id';
/**
 * Parses a carousel state out of HTML elements present inside of `el`.
 * @param el Parent <fbs-carousel> or `fbs-slider` element
 * @param config Current carousel active configuration
 */
function initFromDom(el, config) {
    var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */] ? document : config.serverDomEngine;
    var state = {
        __slides: new Map(),
        __order: [],
        __index: config.initialIndex || 0,
    };
    var slideWrapper;
    var slides = [];
    var uniqueId = '';
    el.classList.add('fbs-slider');
    // If carousel has no ID, give it a unique string for server side styles to apply
    if (el.id) {
        uniqueId = "#" + el.id;
    }
    else if (el.hasAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */])) {
        uniqueId = el.getAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */]);
        el.classList.add(uniqueId);
    }
    else {
        uniqueId = "_" + generateSlideId(state.__slides);
        el.setAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */], uniqueId);
        el.classList.add(uniqueId);
    }
    for (var i = 0; i < el.children.length; i++) {
        var child = el.children.item(i);
        // Handle importing existing control buttons
        if (child.classList.contains(CONTROL_WRAPPER_CLASS)) {
            // Only one controls allowed
            if (state.__controls) {
                child.remove();
                i--;
                continue;
            }
            var left = child.querySelector("." + CONTROL_LEFT_CLASS);
            var right = child.querySelector("." + CONTROL_RIGHT_CLASS);
            state.__controls = {
                __wrapper: child,
                __left: left,
                __right: right,
            };
            // Import slide wrapper and store for later use
        }
        else if (child.classList.contains(SLIDE_WRAPPER_CLASS)) {
            // Only one slide wrapper allowed
            if (slideWrapper) {
                child.remove();
                i--;
                continue;
            }
            slideWrapper = child;
            // By this point it's probably a slide
        }
        else {
            slides.push(child);
        }
    }
    /**
     * Converts all remaining elements to valid slides.
     * @param slides Array of all remaining matched nodes
     * @param removeMatched Detach DOM node after converting to valid slide?
     *                      Required for converting from trackless slide
     */
    var validateSlides = function (slides, removeMatched) {
        // Populate the state slides array
        slides.forEach(function (slide) {
            // If a slides array was present the only nodes allowed are prerendered ID'ed content
            if (config.slides) {
                var found = void 0;
                var attribute = slide.getAttribute(SLIDER_SLIDE_ID);
                for (var i = 0; i < config.slides.length; i++) {
                    if (attribute && attribute === config.slides[i].id) {
                        found = config.slides[i];
                        break;
                    }
                }
                if (found) {
                    found.domNode = slide;
                    state.__slides.set(found.id, found);
                }
                else {
                    slide.remove();
                }
                // Otherwise, all slides are valid. Run initial construction
            }
            else {
                var slideMeta = {
                    id: generateSlideId(state.__slides),
                    domNode: slide,
                    scope: {},
                };
                createSlideNode(slideMeta, config);
                state.__slides.set(slideMeta.id, slideMeta);
                state.__order.push(slideMeta.id);
            }
            if (removeMatched) {
                el.removeChild(slide);
            }
        });
    };
    if (slideWrapper) {
        state.__track = slideWrapper.querySelector("." + SLIDE_TRACK_CLASS);
        validateSlides(Array.prototype.slice.call(state.__track.children));
        // If a slide wrapper was found, all other remaining nodes are invalid
        slides.forEach(function (slide) {
            slide.remove();
        });
    }
    else {
        validateSlides(slides, true);
        slideWrapper = _document.createElement('div');
        slideWrapper.classList.add(SLIDE_WRAPPER_CLASS);
        state.__track = _document.createElement('div');
        state.__track.classList.add(SLIDE_TRACK_CLASS);
        slideWrapper.appendChild(state.__track);
        el.insertBefore(slideWrapper, el.childNodes[0]);
    }
    state.__wrapper = slideWrapper;
    // Handle control creation/removal
    if (!state.__controls) {
        state.__controls = {};
    }
    // When carousel uses slide configuration over DOM, all slides must be preloded
    // into __slides on init
    if (config.slides) {
        for (var i = 0; i < config.slides.length; i++) {
            var slideConfig = {};
            if (!config.slides[i].id) {
                slideConfig.id = generateSlideId(state.__slides);
            }
            if (!state.__slides.has(slideConfig.id)) {
                slideConfig = __assign({}, slideConfig, config.slides[i]);
                state.__slides.set(slideConfig.id, slideConfig);
            }
            state.__order.push(slideConfig.id);
        }
    }
    // @TODO find somewhere better for this
    if (config.looping &&
        config.inView + (config.slidesToScroll * 2) > state.__order.length) {
        config.looping = false;
    }
    state.__active_slides = updateSlides(el, state, config, true);
    // Now that slides have been created/indexed, dump prerender styles and carousel
    // initialization state to the client
    Object(__WEBPACK_IMPORTED_MODULE_0__serverHelpers__["a" /* prerenderBootstrapHelper */])(el, config, state, uniqueId);
    return state;
}
/**
 * Creates missing control elements if required
 * @param controls Current controls object on the state
 * @param _document Current document render context
 * Returns new control state
 */
function createControls(controls, _document) {
    if (!controls.__wrapper) {
        var controlWrapper = _document.createElement('div');
        controlWrapper.classList.add(CONTROL_WRAPPER_CLASS);
        controls.__wrapper = controlWrapper;
    }
    ['left', 'right'].forEach(function (dir) {
        if (!controls["__" + dir]) {
            var control = _document.createElement('button');
            var svgName = "arrow" + (dir === 'left' ? 'Left' : 'Right');
            control.innerHTML = __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons___default.a[svgName];
            control.classList.add(dir === 'left' ? CONTROL_LEFT_CLASS : CONTROL_RIGHT_CLASS);
            control.setAttribute('title', "" + (dir === 'left' ? 'Previous' : 'Next'));
            controls.__wrapper.appendChild(control);
            controls["__" + dir] = control;
        }
    });
    return controls;
}
/**
 * Creates a new DOM node with the slide content.
 * If one already exists and is stored, it returns that instead of creating a new one.
 *
 * @TODO - Too many slide nodes created at once will bog down the browser from detached DOM trees.
 * Perhaps implement some kind of LRU cache purge of old slide domNodes?
 * @param slideData
 * @param config
 */
function createSlideNode(slideData, config) {
    var node;
    var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */] ? document : config.serverDomEngine;
    if (slideData.domNode) {
        node = slideData.domNode;
    }
    else if (slideData.textContent) {
        var container = _document.createElement('div');
        container.innerHTML = slideData.textContent;
        delete slideData.textContent;
        if (container.firstElementChild.classList.contains(SLIDE_CLASS)) {
            container = container.firstElementChild;
        }
        node = container;
    }
    else if (config.slideGenerator) {
        node = config.slideGenerator(slideData.scope, __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */] ? document : config.serverDomEngine);
    }
    else {
        console.error("WARNING: Slide " + slideData.id + " was generated with no content! Provide a generator function.");
        node = _document.createElement('div');
    }
    node.classList.add(SLIDE_CLASS);
    node.setAttribute(SLIDER_SLIDE_ID, slideData.id);
    // Load async images from slide
    // Don't load image attributes when server-side rendering, it's handled later during the style dump
    // @TODO ...maybe rethink this
    if (!config.isServerPrerender) {
        var datasetLocation = config.imagePreloadAttribute.split('-')
            .filter(function (val) { return val.toLowerCase() !== 'data'; })
            .map(function (val, idx) { return idx === 0 ? val : "" + val.slice(0, 1).toUpperCase() + val.slice(1); })
            .join('');
        if (node.imagesPreloaded !== datasetLocation) {
            var imagePreload = node.querySelectorAll("*[" + config.imagePreloadAttribute + "]");
            for (var i = 0; i < imagePreload.length; i++) {
                imagePreload[i].style.backgroundImage = "url(" + imagePreload[i].dataset[datasetLocation] + ")";
            }
            // Don't try to load this image again
            node.imagesPreloaded = datasetLocation;
        }
    }
    slideData.domNode = node;
    // Callback for the first time createSlideNode is called on a slide
    if (!node.fbsCalledback) {
        if (config.slideGeneratedCallback) {
            config.slideGeneratedCallback(slideData);
            // Don't try to load this image again
            node.fbsCalledback = true;
        }
    }
    return node;
}
/**
 * Generates a new, random slide ID. No duplicates.
 * @param slides Existing slide pool to check for duplicates
 */
function generateSlideId(slides) {
    var slideId;
    do {
        slideId = (Math.random() * 1e20).toString(28);
    } while (slides.has(slideId));
    return slideId;
}
/**
 * Inserts and removes controls based on active configuration. Adds enabled/disabled classes if non-looping and required
 * @param el Parent <fbs-carousel> or `fbs-slider` element
 * @param state Current carousel state.
 * @param config Carousel active configuration.
 */
function toggleControls(el, state, config) {
    var controlsActive = config.showControls && config.enabled !== false;
    if (controlsActive && !state.__controls.__wrapper) {
        var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */] ? document : config.serverDomEngine;
        state.__controls = createControls(state.__controls, _document);
        el.insertBefore(state.__controls.__wrapper, state.__wrapper.nextSibling);
    }
    else if (state.__controls.__wrapper) {
        if (controlsActive) {
            el.classList.remove(CONTROL_DISABLED_WRAPPER_CLASS);
        }
        else {
            el.classList.add(CONTROL_DISABLED_WRAPPER_CLASS);
        }
    }
    // Enable/disable control arrows for non-looping carousels
    // Also disables control arrows for server prerenders
    var cb = function (el, enabled) {
        if (enabled) {
            el.classList.remove(CONTROL_DISABLED_CLASS);
        }
        else {
            el.classList.add(CONTROL_DISABLED_CLASS);
        }
    };
    var left = state.__controls.__left;
    var right = state.__controls.__right;
    if (left) {
        cb(left, !((!config.looping && state.__index === 0) || config.isServerPrerender));
    }
    if (right) {
        cb(right, !((!config.looping && state.__index + config.inView >= state.__order.length) || config.isServerPrerender));
    }
}
/**
 * Updates carousel display state to match new state.__order
 * @param el Parent <fbs-carousel> or `fbs-slider` element
 * @param state Current carousel state.
 * @param config Carousel active configuration.
 * @param resized Has a resize event happened since the last time this ran?
 */
function updateSlides(el, state, config, resized) {
    if (resized === void 0) { resized = false; }
    var displayedSlides = [];
    // @TODO: Support looping element cloning
    // Preload slidesToScroll slides left, if available
    // If running a server render, only show visible slides
    var startIndex = config.isServerPrerender ? state.__index : state.__index - config.slidesToScroll;
    if (!config.looping) {
        startIndex = Math.max(0, startIndex);
    }
    // Show inView slides, then preload slidesToScroll slides right
    // If running a server prerender, only show visible slides
    var endIndex = state.__index + config.inView + (config.isServerPrerender ? 0 : config.slidesToScroll);
    if (!config.looping) {
        endIndex = Math.min(state.__order.length, endIndex);
    }
    // If any breakpoint in the carousel has a disabled attribute, then need to dump every slide regardless of preloading rules
    if (config.enabled === false || (config.isServerPrerender && config.hasDisabledBreakpoint)) {
        startIndex = 0;
        endIndex = state.__order.length;
    }
    // Track all current children
    for (var i = 0; i < state.__track.childNodes.length; i++) {
        state.__track.removeChild(state.__track.childNodes[0]);
        i--;
    }
    // Only need to reset carousel/track level sizings on parent resize
    if (resized) {
        state.__viewWidth = state.__wrapper.getBoundingClientRect().width;
        state.__slideWidth = state.__viewWidth / config.inView;
        // Server track size is controlled by dumped CSS
        if (!config.isServerPrerender && config.enabled !== false) {
            state.__track.style.width = (state.__slideWidth) * (endIndex - startIndex) + "px";
        }
        else {
            state.__track.style.width = '100%';
        }
    }
    // @TODO - Don't reset this number if not strictly required
    // Needed on slide change and resize
    var offset = -(state.__slideWidth * config.slidesToScroll);
    if (!config.looping) {
        offset = -(state.__slideWidth * Math.min(config.slidesToScroll, state.__index));
    }
    if (config.isServerPrerender || config.enabled === false) {
        offset = 0;
    }
    state.__track.style.transform = "translateX(" + offset + "px)";
    state.__translationOffset = offset;
    for (var i = startIndex; i < endIndex; i++) {
        var currentSlideId = Object(__WEBPACK_IMPORTED_MODULE_1__utility__["g" /* loopIndexOrder */])(state.__order, i);
        var currentSlide = state.__slides.get(currentSlideId);
        var slide = createSlideNode(currentSlide, config);
        var inView = i >= state.__index && i < state.__index + config.inView;
        displayedSlides.push({
            inView: inView,
            slideData: currentSlide,
        });
        if (inView && i === state.__index + config.currentOffset) {
            slide.classList.add('active', 'primary');
            setAccessibility(slide, true);
        }
        else if (inView) {
            slide.classList.add('active');
            slide.classList.remove('primary');
            setAccessibility(slide, true);
        }
        else {
            slide.classList.remove('active', 'primary');
            setAccessibility(slide, false);
        }
        if (!config.isServerPrerender && config.enabled !== false) {
            slide.style.width = (state.__slideWidth) + "px";
        }
        else if (config.enabled === false) {
            slide.style.width = '';
        }
        state.__track.appendChild(slide);
    }
    // If the number of slides changed, and not on the server, then update the track width
    if (displayedSlides.length !== (state.__active_slides || []).length && !config.isServerPrerender && config.enabled !== false) {
        state.__track.style.width = (state.__slideWidth) * (endIndex - startIndex) + "px";
    }
    toggleControls(el, state, config);
    return displayedSlides;
}
/**
 * Hides slide from screen readers if not in view
 * @param slide carousel slide
 * @param show slide state
 */
function setAccessibility(slide, show) {
    slide.setAttribute('aria-hidden', "" + !show);
    slide.setAttribute('tabindex', "" + (show ? 0 : -1));
    var links = Array.from(slide.querySelectorAll('a'));
    links.forEach(function (link) {
        link.setAttribute('aria-hidden', "" + !show);
        link.setAttribute('tabindex', "" + (show ? 0 : -1));
    });
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FbsCarousel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers_utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers_dom__ = __webpack_require__(2);
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var FbsCarousel = /** @class */ (function () {
    /**
     * Creates a new fbs-carousel from scratch
     * @param el HTML element of base level element. Required. Must be either <fbs-carousel> or have class `fbs-slider`
     * @param config Optional configuration value to use. If not passed loads from window, or defaults.
     *               See `Utility.findCurrentConfiguration` for more.
     */
    function FbsCarousel(el, config) {
        this.el = el;
        this.isAnimating = false;
        this.__config = config;
    }
    FbsCarousel.prototype.init = function () {
        // An element is required to configure a carousel correctly.
        if (!this.el) {
            return;
        }
        this.loadConfiguration(this.__config);
        this.loadState();
        this.el.classList.add('fbs-slider--initialized');
        this.registerEvents();
        this.triggerEvent('sliderInitialized', {
            currentSlide: this.getCurrentSlide(),
        });
    };
    FbsCarousel.prototype.uninit = function () {
        this.unregisterEvents();
        this.triggerEvent('sliderDestroyed', {
            currentSlide: this.getCurrentSlide(),
        });
    };
    /**
     * Sets global and active configurations
     * @param config Starting configuration to use, otherwise load from default locations
     */
    FbsCarousel.prototype.loadConfiguration = function (config) {
        this.__config = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["b" /* findCurrentConfiguration */])(config, this.el);
        this.__active_config = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["c" /* generateActiveConfiguration */])(this.__config);
    };
    /**
     * Initializes carousel state from loaded config.
     * This function should *only* be called from init(), and will reset a carousel back to initial configuration values.
     *
     * Only use this function when actually necessary. It's extremely expensive.
     */
    FbsCarousel.prototype.loadState = function () {
        // Generate initial carousel state from child DOM elements
        this.__state = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["g" /* initFromDom */])(this.el, this.__active_config);
    };
    /**
     * Registers event handlers for touch and mouse drag, window resize, orientation change
     */
    FbsCarousel.prototype.registerEvents = function () {
        var _this = this;
        // Register prev/next buttons
        if (this.__state.__controls.__left) {
            this.__state.__controls.__left.addEventListener('click', function () { return _this.goPrev(); });
        }
        if (this.__state.__controls.__right) {
            this.__state.__controls.__right.addEventListener('click', function () { return _this.goNext(); });
        }
        this.handleSwipe();
        if (typeof window !== 'undefined') {
            window.addEventListener('resize', this.resize.bind(this));
            window.addEventListener('orientationchange', this.resize.bind(this));
        }
    };
    /**
     * Don't leak your listeners
     */
    FbsCarousel.prototype.unregisterEvents = function () {
        // @TODO
    };
    /**
     * Changes slide index
     * @param slidesToChange Number of slides to move left/right
     * @returns True if carousel is attempting to change slide index, false if it failed for any reason
     */
    FbsCarousel.prototype.go = function (slidesToChange) {
        var _this = this;
        if (slidesToChange === void 0) { slidesToChange = 0; }
        var delta = slidesToChange;
        // Bail if currently mid-slide change
        if (this.isAnimating) {
            return false;
        }
        // If not an infinite looping carousel, normalize to maximum distance allowed
        if (!this.__active_config.looping) {
            if (this.__state.__index + delta < 0) {
                delta = -this.__state.__index;
            }
            if (this.__state.__index + delta + this.__active_config.inView > this.__state.__order.length) {
                delta = Math.max(0, this.__state.__order.length - (this.__state.__index + this.__active_config.inView));
            }
        }
        // Don't do anything if you're not actually going anywhere
        if (this.__active_config.enabled === false || delta % this.__state.__order.length === 0) {
            return false;
        }
        // Broadcast the slide we are going to next.
        var currentSlide = this.getCurrentSlide();
        var targetSlide = this.__state.__slides.get(Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["g" /* loopIndexOrder */])(this.__state.__order, this.__state.__index + delta + this.__active_config.currentOffset));
        this.triggerEvent('slideChangeStart', {
            currentSlide: currentSlide,
            targetSlide: targetSlide,
        });
        /**
         * Update the carousel index and rerender the slides.
         * Also fires the completed `slideChanged` event
         * Called either after transition if within viewing distance, or immediately if out of range.
         */
        var changeSlide = (function () {
            _this.__state.__index = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["f" /* loopIndex */])(_this.__state.__index + delta, _this.__state.__order.length);
            _this.__state.__active_slides = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["h" /* updateSlides */])(_this.el, _this.__state, _this.__active_config, false);
            _this.triggerEvent('slideChanged', {
                previousSlide: currentSlide,
                currentSlide: targetSlide,
            });
        }).bind(this);
        // Figure out how many slides left and right need to transition
        var distances = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["d" /* getDistances */])(this.__state.__index, Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["f" /* loopIndex */])(this.__state.__index + delta, this.__state.__order.length), this.__state.__order.length);
        // If moving more than the maximum allowable slides, don't animate.
        // In a looping carousel, use straight line distance left/right to calculate maximums
        if ((this.__active_config.looping &&
            distances[0] > this.__active_config.slidesToScroll &&
            distances[1] > this.__active_config.slidesToScroll) ||
            // In a non-looping, use simple slide change index value
            (!this.__active_config.looping && Math.abs(delta) > this.__active_config.slidesToScroll)) {
            // Bypass animations
            changeSlide();
            return true;
        }
        // Start sliding in the direction requested
        this.isAnimating = true;
        this.__state.__track.classList.add(FbsCarousel.ANIMATING_CLASS);
        // Calculate translate pixel distance based on number of slides to transition and apply it.
        // Give it a quick timeout to allow the classList add to complete and give the transitions
        var transitionOffset = this.__active_config.looping ?
            (distances[0] > distances[1] ? distances[1] : -distances[0]) : delta;
        var offset = this.__state.__translationOffset - (this.__state.__slideWidth * transitionOffset);
        setTimeout(function () {
            _this.__state.__track.style.transform = "translateX(" + offset + "px)";
        }, 0);
        // After transform has finished CSS transitioning, remove transition class and rerender the
        // slide list
        setTimeout(function () {
            _this.isAnimating = false;
            _this.__state.__track.classList.remove(FbsCarousel.ANIMATING_CLASS);
            changeSlide();
        }, this.__active_config.speed);
        return true;
    };
    /**
     * Handy go() aliases
     */
    FbsCarousel.prototype.goPrev = function () {
        return this.go(-(this.__active_config.slidesToScroll));
    };
    FbsCarousel.prototype.goNext = function () {
        return this.go(this.__active_config.slidesToScroll);
    };
    FbsCarousel.prototype.goToIndex = function (index) {
        return this.go(index - this.__state.__index);
    };
    FbsCarousel.prototype.goToSlideById = function (slideId) {
        var index = this.__state.__order.indexOf(slideId);
        return index === -1 ? false : this.goToIndex(index);
    };
    // @TODO Refactor touch events again after SSR is handled more sanely
    FbsCarousel.prototype.handleSwipe = function () {
        var _this = this;
        var touchstartX = 0;
        var touchendX = 0;
        var startWinY = 0;
        var thresholdX = 50;
        var thresholdY = 50;
        function tooMuchY(start, end) {
            if (start > end) {
                return start - end > thresholdY;
            }
            else {
                return end - start > thresholdY;
            }
        }
        this.el.addEventListener('touchstart', function (event) {
            touchstartX = event.changedTouches[0].screenX;
            startWinY = window.pageYOffset;
        }, { passive: true });
        this.el.addEventListener('touchend', function (event) {
            touchendX = event.changedTouches[0].screenX;
            if (!tooMuchY(startWinY, window.pageYOffset)) {
                if (touchendX < touchstartX && (touchstartX - touchendX > thresholdX)) {
                    _this.go(_this.__active_config.slidesToScroll);
                }
                else if (touchendX > touchstartX && (touchendX - touchstartX > thresholdX)) {
                    _this.go(-_this.__active_config.slidesToScroll);
                }
            }
        }, { passive: true });
    };
    /**
     * Custom event interceptor
     * @TODO - Add window object level callbacks in config
     * @param event Event name
     * @param detail Data to pass alongside event
     */
    FbsCarousel.prototype.triggerEvent = function (event, detail) {
        if (typeof CustomEvent !== 'undefined') {
            this.el.dispatchEvent(new CustomEvent(event, {
                detail: __assign({}, detail, { activeSlides: this.__state.__active_slides }),
            }));
        }
    };
    /**
     * Resizes the carousel
     * Rerenders the current slide state with updated width information
     * Fires on window resize and orientation change
     * Can be manually called by the custom element, or class interface
     */
    FbsCarousel.prototype.resize = function () {
        this.loadConfiguration(this.__config);
        // @TODO find somewhere better for this
        // Disable looping if the carousel is too small for it at this breakpoint
        if (this.__active_config.looping &&
            this.__active_config.inView + (this.__active_config.slidesToScroll * 2) > this.__state.__order.length) {
            this.__active_config.looping = false;
        }
        // Move back a slide if you change the number of visible slides on us
        if (!this.__active_config.looping && this.__state.__index + this.__active_config.inView > this.__state.__order.length) {
            this.__state.__index = Math.max(0, this.__state.__order.length - this.__active_config.inView);
        }
        this.__state.__active_slides = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["h" /* updateSlides */])(this.el, this.__state, this.__active_config, true);
        this.triggerEvent('sliderResized', {
            currentSlide: this.getCurrentSlide(),
        });
    };
    /**
     * Returns current active slide data. Only returns data for __index, not all inView slides.
     */
    FbsCarousel.prototype.getCurrentSlide = function () {
        return this.__state.__slides.get(this.__state.__order[this.__state.__index + this.__active_config.currentOffset]);
    };
    /**
     * Returns list of all slides currently added to dom.
     */
    FbsCarousel.prototype.getActiveSlides = function () {
        return this.__state.__active_slides;
    };
    /**
     * Adds slides to the carousel at provided index.
     * If no index is provided, then slide will be inserted at the end.
     * @param slideData[] Slide data used to generate the new slide(s)
     * @param index Location to insert the slide. Default end.
     * @param adjustIndex If slides are inserted before the currently visible slide, adjust
     * 					  index to keep user on the intended slide?
     * @returns Slide IDs if slides were inserted successfully
     */
    FbsCarousel.prototype.addSlides = function (slideData, index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        var _a;
        if (!index && index !== 0) {
            index = this.__state.__order.length;
        }
        var slides = [];
        for (var i = 0; i < slideData.length; i++) {
            if (!slideData[i].id || this.__state.__slides.has(slideData[i].id)) {
                slideData[i].id = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["f" /* generateSlideId */])(this.__state.__slides);
            }
            this.__state.__slides.set(slideData[i].id, slideData[i]);
            slides.push(slideData[i].id);
        }
        (_a = this.__state.__order).splice.apply(_a, [Math.max(0, Math.min(this.__state.__order.length, index)), 0].concat(slides));
        if (adjustIndex && this.__state.__index >= index) {
            this.__state.__index += slides.length;
        }
        // @TODO - Resize may stop working depending on how the diffing algorithm changes
        this.resize();
        return slides;
    };
    FbsCarousel.prototype.addSlide = function (slideData, index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.addSlides([slideData], index, adjustIndex)[0];
    };
    /**
     * Removes slides by ID. Not limited to any specific index groupings.
     * @param slideIds Array of slide ID strings to remove
     * @param adjustIndex If slides are removed before the currently visible slide, adjust
     * 					  index to keep user on the intended slide?
     * @returns List of slide IDs that were successfully removed
     */
    FbsCarousel.prototype.removeSlides = function (slideIds, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        var success = [];
        var adjustment = 0;
        for (var i = 0; i < slideIds.length; i++) {
            var index = this.__state.__order.indexOf(slideIds[i]);
            if (index !== -1) {
                var slideId = this.__state.__order[index];
                if (index < this.__state.__index) {
                    adjustment--;
                }
                success.push(slideId);
                this.__state.__slides.delete(slideId);
                this.__state.__order.splice(index, 1);
            }
        }
        if (adjustIndex) {
            this.__state.__index += adjustment;
        }
        // @TODO - Resize may stop working depending on how the diffing algorithm changes
        this.resize();
        return success;
    };
    FbsCarousel.prototype.removeSlide = function (slideId, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.removeSlides([slideId], adjustIndex)[0];
    };
    /**
     * Helper function to remove slides by ID. By using the function removeSlide which uses IDs alone,
     * there are no issues with slide removal batching. No need to progressively adjust indexes!
     * @param index Array of slide indexes to remove
     * @param adjustIndex If slides are removed before the currently visible slide, adjust
     * 					  index to keep user on the intended slide?
     * @return List of slide IDs that were successfully removed
     */
    FbsCarousel.prototype.removeSlidesByIndex = function (index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        var slides = [];
        for (var i = 0; i < index.length; i++) {
            var slide = this.__state.__order[index[i]];
            if (slide && slides.indexOf(slide) === -1) {
                slides.push(slide);
            }
        }
        if (slides.length > 0) {
            return this.removeSlides(slides, adjustIndex);
        }
        return [];
    };
    FbsCarousel.prototype.removeSlideByIndex = function (index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.removeSlidesByIndex([index], adjustIndex)[0];
    };
    FbsCarousel.prototype.getEl = function () {
        return this.el;
    };
    FbsCarousel.ANIMATING_CLASS = 'is-animating';
    return FbsCarousel;
}());



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = prerenderBootstrapHelper;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dom__ = __webpack_require__(2);
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



/**
 * Creates all required settings for client-side rendering and bootstrap
 * @param el Parent <fbs-carousel> or `fbs-slider` element
 * @param config Current carousel active configuration
 * @param state Current carousel state
 * @param id Current unique identifier for the carousel
 */
function prerenderBootstrapHelper(el, config, state, id) {
    // If running server-side prerender, dump style tag with complete render information
    if (config.isServerPrerender) {
        var start_1 = config.hasDisabledBreakpoint ? 0 : state.__index;
        var end_1 = config.hasDisabledBreakpoint ? state.__active_slides.length : state.__index + config.inView;
        var visibleSlides_1 = [];
        // If a slides array is present in configuration, update slide IDs stored
        // so that the client will correctly import the rendered slides on bootstrap
        if ((config.originalConfig.slides || []).length) {
            state.__order.slice(start_1, end_1).forEach(function (slide, i) {
                var slideData = state.__slides.get(slide);
                visibleSlides_1.push(slideData);
                config.originalConfig.slides[start_1 + i].id = slideData.id;
            });
            // If no config or slide list was provided, then we need to save slide state or some will be missing.
        }
        else {
            config.originalConfig.slides = [];
            state.__order.forEach(function (slide, index) {
                var slideData = __assign({}, state.__slides.get(slide));
                // If a slide is out of view, then need to dump the textContent so we don't lose the slide
                if (index < start_1 || index >= end_1) {
                    slideData.textContent = slideData.domNode.outerHTML;
                    delete slideData.id;
                }
                else {
                    visibleSlides_1.push(__assign({}, slideData));
                }
                delete slideData.domNode;
                config.originalConfig.slides.push(slideData);
            });
        }
        // Handle style output
        var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */] ? document : config.serverDomEngine;
        var styles = _document.createElement('style');
        var stylePrefix_1 = id.indexOf('#') === 0 ? id : "." + id;
        var baseStyle = "\n\t\t\tfbs-carousel {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t\t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["e" /* SLIDE_TRACK_CLASS */] + " {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t";
        var imageIndex_1 = 0;
        // Array to store all breakpoints that still need parsed.
        // Unlike elsewhere that checks the original configuration values (Without defaults), this needs to use
        // default values on the top level if and only if no custom configuration was provided.
        var breakpointTree = [{
                config: __assign({}, __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */], (Object.keys(config.originalConfig).length > 0 ? config.originalConfig : config)),
            }];
        var breakpointCss_1 = [baseStyle];
        var cb = function (breakpoint) {
            var _config = breakpoint.config;
            // Dump mediaquery if present
            if (breakpoint.breakpoint) {
                breakpointCss_1.push(breakpoint.breakpoint + " {");
            }
            // Show/hide controls at this breakpoint
            breakpointCss_1.push("\n\t\t\t\t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["a" /* CONTROL_WRAPPER_CLASS */] + " {\n\t\t\t\t\tdisplay: " + (_config.enabled !== false && _config.showControls !== false ? 'block' : 'none') + ";\n\t\t\t\t}\n\t\t\t");
            // Loop over slides currently visible at this breakpoint
            for (var i = 0; i < visibleSlides_1.length; i++) {
                var slide = visibleSlides_1[i];
                breakpointCss_1.push(stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["d" /* SLIDE_CLASS */] + "[" + __WEBPACK_IMPORTED_MODULE_2__dom__["c" /* SLIDER_SLIDE_ID */] + "=\"" + slide.id + "\"] {");
                // If the slide is in view, set it visible and give it a width in percentage
                if (i < _config.inView || _config.enabled === false) {
                    breakpointCss_1.push("\n\t\t\t\t\t\tdisplay: block;\n\t\t\t\t\t\twidth: " + (_config.enabled === false ? 'auto' : 100 / _config.inView + "%") + ";}\n\t\t\t\t\t");
                    // In-view slides get a background-image if it found one!
                    if (slide.domNode) {
                        var selector = _config.imagePreloadAttribute || 'data-bg-image';
                        var images = slide.domNode.querySelectorAll("*[" + selector + "]");
                        for (var index = 0; index < images.length; index++) {
                            var node = images.item(index);
                            breakpointCss_1.push("\n\t\t\t\t\t\t\t \t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["d" /* SLIDE_CLASS */] + "[" + __WEBPACK_IMPORTED_MODULE_2__dom__["c" /* SLIDER_SLIDE_ID */] + "=\"" + slide.id + "\"] .ssr-i-" + imageIndex_1 + " {\n\t\t\t\t\t\t\t\tbackground-image: url(" + node.getAttribute(selector) + ");}\n\t\t\t\t\t\t\t");
                            node.classList.add("ssr-i-" + imageIndex_1++);
                        }
                    }
                    // Otherwise hide it
                }
                else {
                    breakpointCss_1.push('display: none;}');
                }
            }
            // If a mediaquery was started, need to end it
            if (breakpoint.breakpoint) {
                breakpointCss_1.push('}');
            }
        };
        var _loop_1 = function () {
            var breakpoint = breakpointTree.pop();
            if (((breakpoint.config || {}).breakpoints || []).length) {
                breakpointTree.push.apply(breakpointTree, breakpoint.config.breakpoints.map(function (childBreakpoint) { return (__assign({}, childBreakpoint, { config: __assign({}, breakpoint.config, { breakpoints: [] }, childBreakpoint.config) })); }));
            }
            cb(breakpoint);
        };
        while (breakpointTree.length > 0) {
            _loop_1();
        }
        styles.setAttribute(__WEBPACK_IMPORTED_MODULE_2__dom__["b" /* SLIDER_PRERENDER_STYLES */], '');
        styles.setAttribute('type', 'text/css');
        styles.innerHTML = breakpointCss_1.join('\n').replace(/\t/gi, '');
        el.insertBefore(styles, el.firstElementChild);
        // Handle script output
        // Super easy, comparatively
        var script = _document.createElement('script');
        script.appendChild(_document.createTextNode(("\n\t\twindow.FbsCarouselConfig = window.FbsCarouselConfig || {};\n\t\twindow.FbsCarouselConfig['" + stylePrefix_1.slice(1) + "'] = " + JSON.stringify(config.originalConfig) + ";\n\t\t").replace(/\t/gi, '')));
        el.appendChild(script);
    }
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = {
	arrowLeft: '<svg class="fs-icon fs-icon--arrow-left" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 10h16v2h-16z"/><path transform="rotate(-45.001 4.5 8.877)" d="M.5 7.9h8v2h-8z"/><path transform="rotate(45.001 4.5 13.124)" d="M.5 12.1h8v2h-8z"/></svg>',
	arrowRight: '<svg class="fs-icon fs-icon--arrow-right" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path transform="rotate(-180 8.964 11)" d="M1 10h16v2H1z"/><path transform="rotate(134.999 14.965 13.124)" d="M11 12.1h8v2h-8z"/><path transform="rotate(-134.999 14.965 8.877)" d="M11 7.9h8v2h-8z"/></svg>',
	chevronDown: '<svg class="fs-icon fs-icon--chevron-down" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(-134.999 7.586 10.187)" d="M2.8 9h9.5v2.4H2.8z"/><path transform="rotate(-45.001 12.615 10.187)" d="M7.9 9h9.5v2.4H7.9z"/></svg>',
	chevronLeft: '<svg class="fs-icon fs-icon--chevron-left" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(-45.001 10.1 7.672)" d="M5.4 6.5h9.5v2.4H5.4z"/><path transform="rotate(45.001 10.1 12.701)" d="M5.4 11.5h9.5v2.4H5.4z"/></svg>',
	chevronRight: '<svg class="fs-icon fs-icon--chevron-right" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(134.999 10.1 12.701)" d="M5.4 11.5h9.5v2.4H5.4z"/><path transform="rotate(-134.999 10.1 7.672)" d="M5.4 6.5h9.5v2.4H5.4z"/></svg>',
	chevronUp: '<svg class="fs-icon fs-icon--chevron-up" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(45.001 12.615 10.187)" d="M7.9 9h9.5v2.4H7.9z"/><path transform="rotate(134.999 7.586 10.187)" d="M2.8 9h9.5v2.4H2.8z"/></svg>',
	close: '<svg class="fs-icon fs-icon--close" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path transform="rotate(45.001 10 10)" d="M2 9h16v2H2z"/><path transform="rotate(134.999 10 10)" d="M2 9h16v2H2z"/></svg>',
	forbesLogo: '<svg class="fs-icon fs-icon--forbes-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 54"><path d="M113.3 18.2c0-5.8.1-11.2.4-16.2L98.4 4.9v1.4l1.5.2c1.1.1 1.8.5 2.2 1.1.4.7.7 1.7.9 3.2.2 2.9.4 9.5.3 19.9 0 10.3-.1 16.8-.3 19.3 5.5 1.2 9.8 1.7 13 1.7 6 0 10.7-1.7 14.1-5.2 3.4-3.4 5.2-8.2 5.2-14.1 0-4.7-1.3-8.6-3.9-11.7-2.6-3.1-5.9-4.6-9.8-4.6-2.6 0-5.3.7-8.3 2.1zm.3 30.8c-.2-3.2-.4-12.8-.4-28.5.9-.3 2.1-.5 3.6-.5 2.4 0 4.3 1.2 5.7 3.7 1.4 2.5 2.1 5.5 2.1 9.3 0 4.7-.8 8.5-2.4 11.7-1.6 3.1-3.6 4.7-6.1 4.7-.8-.2-1.6-.3-2.5-.4zM41 3H1v2l2.1.2c1.6.3 2.7.9 3.4 1.8.7 1 1.1 2.6 1.2 4.8.8 10.8.8 20.9 0 30.2-.2 2.2-.6 3.8-1.2 4.8-.7 1-1.8 1.6-3.4 1.8l-2.1.3v2h25.8v-2l-2.7-.2c-1.6-.2-2.7-.9-3.4-1.8-.7-1-1.1-2.6-1.2-4.8-.3-4-.5-8.6-.5-13.7l5.4.1c2.9.1 4.9 2.3 5.9 6.7h2V18.9h-2c-1 4.3-2.9 6.5-5.9 6.6l-5.4.1c0-9 .2-15.4.5-19.3h7.9c5.6 0 9.4 3.6 11.6 10.8l2.4-.7L41 3zm-4.7 30.8c0 5.2 1.5 9.5 4.4 12.9 2.9 3.4 7.2 5 12.6 5s9.8-1.7 13-5.2c3.2-3.4 4.7-7.7 4.7-12.9s-1.5-9.5-4.4-12.9c-2.9-3.4-7.2-5-12.6-5s-9.8 1.7-13 5.2c-3.2 3.4-4.7 7.7-4.7 12.9zm22.3-11.4c1.2 2.9 1.7 6.7 1.7 11.3 0 10.6-2.2 15.8-6.5 15.8-2.2 0-3.9-1.5-5.1-4.5-1.2-3-1.7-6.8-1.7-11.3C47 23.2 49.2 18 53.5 18c2.2-.1 3.9 1.4 5.1 4.4zm84.5 24.3c3.3 3.3 7.5 5 12.5 5 3.1 0 5.8-.6 8.2-1.9 2.4-1.2 4.3-2.7 5.6-4.5l-1-1.2c-2.2 1.7-4.7 2.5-7.6 2.5-4 0-7.1-1.3-9.2-4-2.2-2.7-3.2-6.1-3-10.5H170c0-4.8-1.2-8.7-3.7-11.8-2.5-3-6-4.5-10.5-4.5-5.6 0-9.9 1.8-13 5.3-3.1 3.5-4.6 7.8-4.6 12.9 0 5.2 1.6 9.4 4.9 12.7zm7.4-25.1c1.1-2.4 2.5-3.6 4.4-3.6 3 0 4.5 3.8 4.5 11.5l-10.6.2c.1-3 .6-5.7 1.7-8.1zm46.4-4c-2.7-1.2-6.1-1.9-10.2-1.9-4.2 0-7.5 1.1-10 3.2s-3.8 4.7-3.8 7.8c0 2.7.8 4.8 2.3 6.3 1.5 1.5 3.9 2.8 7 3.9 2.8 1 4.8 2 5.8 2.9 1 1 1.6 2.1 1.6 3.6 0 1.4-.5 2.7-1.6 3.7-1 1.1-2.4 1.6-4.2 1.6-4.4 0-7.7-3.2-10-9.6l-1.7.5.4 10c3.6 1.4 7.6 2.1 12 2.1 4.6 0 8.1-1 10.7-3.1 2.6-2 3.9-4.9 3.9-8.5 0-2.4-.6-4.4-1.9-5.9-1.3-1.5-3.4-2.8-6.4-4-3.3-1.2-5.6-2.3-6.8-3.3-1.2-1-1.8-2.2-1.8-3.7s.4-2.7 1.3-3.7 2-1.4 3.4-1.4c4 0 6.9 2.9 8.7 8.6l1.7-.5-.4-8.6zm-96.2-.9c-1.4-.7-2.9-1-4.6-1-1.7 0-3.4.7-5.3 2.1-1.9 1.4-3.3 3.3-4.4 5.9l.1-8-15.2 3v1.4l1.5.1c1.9.2 3 1.7 3.2 4.4.6 6.2.6 12.8 0 19.8-.2 2.7-1.3 4.1-3.2 4.4l-1.5.2v1.9h21.2V49l-2.7-.2c-1.9-.2-3-1.7-3.2-4.4-.6-5.8-.7-12-.2-18.4.6-1 1.9-1.6 3.9-1.8 2-.2 4.3.4 6.7 1.8l3.7-9.3z"/></svg>',
	hamburger: '<svg class="fs-icon fs-icon--hamburger" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 5.5h16v2H2zM2 9.5h16v2H2zM2 13.5h16v2H2z"/></svg>',
	play: '<svg class="fs-icon fs-icon--play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7 2v16.9l11.1-8.5z"/></svg>',
	search: '<svg class="fs-icon fs-icon--search" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="2" cx="8.5" cy="9" r="6"/><path transform="rotate(45.001 14.922 15.421)" d="M12 14.4h5.9v2H12z"/></svg>',
};


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FbsCarouselComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(3);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var FbsCarouselComponent = /** @class */ (function (_super) {
    __extends(FbsCarouselComponent, _super);
    function FbsCarouselComponent(el) {
        var _this = _super.call(this) || this;
        _this.carousel = new __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a" /* FbsCarousel */](_this);
        return _this;
    }
    FbsCarouselComponent.prototype.connectedCallback = function () {
        this.carousel.init();
    };
    FbsCarouselComponent.prototype.disconnectedCallback = function () {
        this.carousel.uninit();
    };
    Object.defineProperty(FbsCarouselComponent.prototype, "currentSlide", {
        /**
         * The following are simple interfaces to interact with the exposed members of the FbsCarousel class
         * See the method documentation for more information.
         */
        get: function () {
            return this.carousel.getCurrentSlide();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FbsCarouselComponent.prototype, "activeSlides", {
        get: function () {
            return this.carousel.getActiveSlides();
        },
        enumerable: true,
        configurable: true
    });
    FbsCarouselComponent.prototype.rerender = function () {
        this.carousel.resize();
    };
    FbsCarouselComponent.prototype.prevSlide = function () {
        return this.carousel.goPrev();
    };
    FbsCarouselComponent.prototype.nextSlide = function () {
        return this.carousel.goNext();
    };
    FbsCarouselComponent.prototype.go = function (slidesToScroll) {
        return this.carousel.go(slidesToScroll);
    };
    FbsCarouselComponent.prototype.goToIndex = function (index) {
        return this.carousel.goToIndex(index);
    };
    FbsCarouselComponent.prototype.goToSlideById = function (slideId) {
        return this.carousel.goToSlideById(slideId);
    };
    FbsCarouselComponent.prototype.addSlide = function (slideData, index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.addSlide(slideData, index, adjustIndex);
    };
    FbsCarouselComponent.prototype.addSlides = function (slideData, index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.addSlides(slideData, index, adjustIndex);
    };
    FbsCarouselComponent.prototype.removeSlide = function (slideIds, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.removeSlide(slideIds, adjustIndex);
    };
    FbsCarouselComponent.prototype.removeSlides = function (slideIds, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.removeSlides(slideIds, adjustIndex);
    };
    FbsCarouselComponent.prototype.removeSlideByIndex = function (index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.removeSlideByIndex(index, adjustIndex);
    };
    FbsCarouselComponent.prototype.removeSlidesByIndex = function (index, adjustIndex) {
        if (adjustIndex === void 0) { adjustIndex = true; }
        return this.carousel.removeSlidesByIndex(index, adjustIndex);
    };
    return FbsCarouselComponent;
}(HTMLElement));



/***/ }),
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(21);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FbsCarousel", function() { return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FbsCarouselComponent", function() { return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["b"]; });



/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(3);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fbs_carousel_component__ = __webpack_require__(6);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__fbs_carousel_component__["a"]; });




/***/ })
/******/ ]);
});