"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharingHashService = void 0;
var SharingHashService = /** @class */ (function () {
    function SharingHashService() {
        this.hash = '';
        this.paramKey = 'sh';
        this.storageKey = 'FORBES_SHARING_TREE_ID';
    }
    /**
     * Get the parent half of the current hash.
     * @returns {string} The parent half of the hash,
     * or the empty string if the page started without a hash.
     */
    SharingHashService.prototype.getParentHash = function () {
        return this.hash.slice(0, 12) !== '2715e4857a0b' ? this.hash.slice(0, 12) : '';
    };
    SharingHashService.prototype.getChildHash = function () {
        return this.hash.slice(12);
    };
    SharingHashService.prototype.getHash = function () {
        return this.hash;
    };
    SharingHashService.prototype.updateStorage = function (newTrackingId) {
        var storageValue = localStorage.getItem(this.storageKey) || undefined;
        var storageValuesArr = storageValue ? storageValue.split(',') : [];
        var currentValue = "".concat(location.pathname, "?").concat(this.paramKey, "=").concat(newTrackingId);
        storageValuesArr.push(currentValue);
        if (storageValuesArr.length >= 20) {
            storageValuesArr.shift();
        }
        localStorage.setItem(this.storageKey, storageValuesArr.join(','));
    };
    /**
     * Updates url string parameter.
     * @param key parameter key to be changed or added.
     * @param value parameter value to be added.
     */
    SharingHashService.prototype.updateUrlQueryParameter = function (key, value) {
        var uri = location.search;
        var re = new RegExp("([?&])".concat(key, "=.*?(&|$)"), 'i');
        var separator = uri.indexOf('?') !== -1 ? '&' : '?';
        if (uri.match(re)) {
            return uri.replace(re, "$1".concat(key, "=").concat(value, "$2"));
        }
        return "".concat(uri).concat(separator).concat(key, "=").concat(value);
    };
    /**
     * Validates if hash contains legacy tracking id.
     * @param hashValue value for location hash.
     * @returns {boolean} True if value is alphanumeric and contains 12 chars
     */
    SharingHashService.prototype.hasTrackingHash = function (hashValue) {
        return /^(?=.*?\d)(?=.*?[a-z])[a-z\d]{12}$/.test(hashValue);
    };
    SharingHashService.prototype.getTrackingParam = function () {
        var urlParams = new URLSearchParams(location.search);
        return urlParams.get(this.paramKey);
    };
    SharingHashService.prototype.updateUrl = function (param) {
        var hashValue = this.hasTrackingHash(location.hash.slice(1)) ? '' : location.hash;
        history.replaceState(history.state || null, '', "".concat(location.pathname).concat(param).concat(hashValue));
    };
    SharingHashService.prototype.setHash = function () {
        var _this = this;
        var hashTrackingValue = this.hasTrackingHash(location.hash.slice(1)) ? location.hash.slice(1) : undefined;
        var currentTrackingId = this.getTrackingParam() || hashTrackingValue;
        var storageValue = localStorage.getItem(this.storageKey) || undefined;
        if (storageValue && currentTrackingId) {
            var storageArrValues = storageValue.split(',');
            var storageObjValues = storageArrValues.map(function (value) {
                var splitValue = value.split("?".concat(_this.paramKey, "="));
                return { urlPath: splitValue[0], shId: splitValue[1] };
            });
            // User go back to the page he already visited (Recurring parent hash).
            var recurringParentIndex = storageObjValues.findIndex(function (item) { return item.shId.slice(0, 12) === currentTrackingId; });
            if (~recurringParentIndex) {
                var recurringParentIndexParam = this.updateUrlQueryParameter(this.paramKey, storageObjValues[recurringParentIndex].shId.slice(12));
                this.updateUrl(recurringParentIndexParam);
                this.hash = storageObjValues[recurringParentIndex].shId;
                return;
            }
            // User reloads or hit back button (Recurring child hash).
            var recurringChildIndex = storageObjValues.findIndex(function (id) { return id.shId.slice(12) === currentTrackingId; });
            if (!!~recurringChildIndex && storageObjValues[recurringChildIndex].urlPath === location.pathname) {
                var childId = storageObjValues[recurringChildIndex].shId;
                var recurringChildParam = this.updateUrlQueryParameter(this.paramKey, childId.slice(12));
                this.updateUrl(recurringChildParam);
                this.hash = childId;
                return;
            }
        }
        // generates new hash
        var trackingId = this.harvestSharingHashTree(currentTrackingId);
        var params = this.updateUrlQueryParameter(this.paramKey, trackingId.slice(12));
        this.updateUrl(params);
        this.updateStorage(trackingId);
    };
    /**
     * Extracts sharing hash tree data from current hash in url
     * @param hash The url hash, without the leading '#' character
     */
    SharingHashService.prototype.harvestSharingHashTree = function (hash) {
        var newHash;
        // Hash can be 12 or 24 characters depending on when it was generated.
        // urls were shortened to only show 12 characters on 1/21/16 build.
        if (hash && (hash.length === 12 || hash.length === 24)) {
            hash = hash.slice(hash.length - 12);
        }
        else {
            var parentHash = this.hash31('WhereDidYouComeFromWhereDidYouGo').toString(16);
            var childHash = this.hash31('SomethingSomethingCottonEyedJoe').toString(16);
            hash = "".concat(parentHash).concat(childHash).slice(0, 12);
        }
        newHash = (((Math.floor(Math.random() * 4096) << 20) | (+new Date() & 0xfffff)) & 0x7fffffff).toString(16);
        newHash += this.pad(this.hash31("".concat(location.protocol, "//").concat(location.host).concat(location.pathname)).toString(16), 4, '0');
        newHash += this.pad(newHash, 4, '0');
        newHash = this.pad(newHash, 12, '0').slice(0, 12);
        this.hash = hash += newHash;
        return hash;
    };
    /**
     * Generates 31 bit hash from a given string
     */
    SharingHashService.prototype.hash31 = function (input) {
        var hash = 2147483647;
        var pointer = input.length;
        while (pointer--) {
            hash = ((hash << 5) - hash + input.charCodeAt(pointer)) & 0x7fffffff;
        }
        return hash;
    };
    /**
     * Pad string to certain length
     * E.G. pad('3', 5, '0') creates '00003'
     * pad('3', 5, '0', true) creates '30000'
     * pad('5', 3, '-') creates '--5'
     * pad('5', 1, '-', true) creates '5'
     */
    SharingHashService.prototype.pad = function (input, limit, padStr, direction) {
        input = "".concat(input);
        while (input.length < limit) {
            input = direction ? input + padStr : padStr + input;
        }
        return input;
    };
    return SharingHashService;
}());
exports.SharingHashService = SharingHashService;
//# sourceMappingURL=sharing-hash.service.js.map