"use strict";
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.batchAsync = void 0;
/**
 * Group of batched tasks to run. Maps completed task results to provided string key in the output.
 * @typedef {Object.<string, BatchAsyncTaskConfig>} BatchAsyncConfig
 */
/**
 * Configuration for a single task operation in a BatchAsync call
 * @typedef {Object} BatchAsyncTaskConfig
 *
 * Task to run for this key. Should return a valid promise.
 * Arguments are passed to this function as available, using `task1.params` followed by resolved
 * data for all keys present in the `requires` key. (params, key1, key2, ...)
 * If no params are present, (key1, key2, ...)
 * @property {function(params, requiredTaskData): Promise} task
 *
 * Should this task be required for this page load to succeed?
 * Defaults 'false'. If an optional task fails, batchAsync will still return successfully.
 * The data for `task1` will be the returned error.
 * If a task isn't optional and fails, batchAsync returns a rejected promise with the first essential error.
 * @property {Boolean} [optional] optional
 *
 * How long to wait before giving up on this task. If this task has dependencies, a timeout is a hard
 * limit. If the task completes after failure, the data is discarded and all dependencies are failed.
 * If there are no dependencies, the task will instead wait until all other active tasks have completed
 * before failing.
 * @property {Number} [timeout] optional
 *
 * Other tasks that this task requires to function correctly. This task will wait to execute until all
 * task keys present in this array have finished resolving before running. The task will be provided the
 * response data for the parent tasks, in order of definition in this array. See `task` definition for more.
 * @property {String[]} [requires] optional
 *
 * Normally, if a task has multiple parents, e.g. 'task3' which has `requires: ['task1', 'task2'],` it
 * requires both parents to succeed for it to run the task. If `allowSingleParentSuccess` is set, it will
 * only require any one of the parents to succeed, instead of all. e.g., task1 or task2 could succeed and
 * task3 will execute, no matter the success or failure of the other. All parents resolve first, regardless.
 * @property {Boolean} [allowSingleParentSuccess] optional
 *
 * If this task errors out, by default it outputs the error to the console (but doesn't halt execution)
 * When enabled, this flag quashes console errors for this optional task
 * @property {Boolean} [silenceOptionalErrors] optional
 */
/**
 * An example task:
 * {
 *     task1: {
 *         task: someSuccessfulTask,
 *     },
 *     task2: {
 *         task: someSuccessfulTask2,
 *         requires: ['task1'],
 *         timeout: 500,
 *     },
 *     task3: {
 *         task: someFailedTask3,
 *         optional: true,
 *     },
 *     task4: {
 *         task: someSuccessfulTask4,
 *         optional: true,
 *         requires: ['task2', 'task3'],
 *     }
 * }
 *
 * would return:
 * {
 *     task1: { ...task1successData },
 *     task2: { ...task2successData },
 *     task3: 'Error: <some error>',
 *     task4: 'Error: Precondition not met: task4.',
 * }
 * task1 and task3 would run simultaneously.
 * When task1 succeeds, task2 starts.
 * Once task2 and task3 have completed, task4 will immediately fail without executing as task3 failed.
 *
 * Assuming task2 times out, the entire operation fails and the promise returns
 * batchAsync(...).catch(error), with error being:
 *     'Error: Task 'task2' timed out!'
 *
 *
 * If task4 had the parameter allowSingleParentSuccess,
 * {
 *     ...,
 *     task4: {
 *         ...,
 *         allowSingleParentSuccess: true,
 *     }
 * }
 *
 * The output would be
 * {
 *     task1: { ...task1successData },
 *     task2: { ...task2successData },
 *     task3: 'Error: <some error>',
 *     task4: { ...task4successData },
 * }
 * Since task2 completed, task4 is allowed to run to completion.
 */
var BatchAsync = /** @class */ (function () {
    /**
     * @param {BatchAsyncConfig} config Keyed map of all requested async tasks to complete. See definition for examples.
     */
    function BatchAsync(config) {
        if (config === void 0) { config = {}; }
        /**
         * @typedef {Object} BatchedTaskStatus
         * All completed tasks, success or failure
         * @property {Object<string, BatchAsyncTaskConfig} resolved
         *
         * All tasks currently started, but still waiting to resolve
         * @property {Object<string, BatchAsyncTaskConfig} active
         *
         * All tasks that have unmet requirements and have yet to start
         * @property {Object<string, BatchAsyncTaskConfig} waiting
         *
         * All tasks that have hit a soft timeout. Hard timeouts (it has dependencies) are not present in this list
         * @property {Object<string, BatchAsyncTaskConfig} timedOut
         */
        /** @type {BatchedTaskStatus} */
        this.tasks = {
            resolved: {},
            active: {},
            waiting: {},
            timedOut: {},
        };
        // Output data of all resolved tasks, stored by input key
        this.resolvedData = {};
        this.init(config);
    }
    /**
     * Sorts tasks into those with and without requirements.
     * Starts all tasks that have no requirements early. If no tasks start, resolve immediately.
     * @param {BatchAsyncConfig} config
     */
    BatchAsync.prototype.init = function (config) {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            // @TODO Is there a better way to handle this? Methods 3 deep need access to these functions
            _this._resolve = resolve;
            _this._reject = reject;
            Object.keys(config).forEach(function (key) {
                var task = config[key];
                if ((task.requires || []).length > 0) {
                    _this.tasks.waiting[key] = task;
                }
                else {
                    _this.tasks.active[key] = task;
                }
            });
            Object.keys(_this.tasks.active).forEach(function (key) {
                var task = _this.tasks.active[key];
                // If a task returned from createTask returns a failure, need to reject the whole batch
                // Optional failures are handled internally
                _this.createTask(key, task).catch(function (error) { return _this._reject(error); });
            });
            if (Object.keys(_this.tasks.active).length === 0) {
                _this._resolve({});
            }
        });
    };
    /**
     * Spawns a single task operation.
     * @param {String} key Name of the current task. Successful task operation stores output in data[key]
     * @param {Object} taskConfig Current task configuration object. Contains task promise and additional settings
     * @returns {Promise<Object>}
     * Tasks that fail, and are required call `reject` with the reason for failure.
     * Otherwise, successful tasks call `resolve` with `true`. Task resolution data
     * is passed in a different way - this promise return is only used for failure notification
     */
    BatchAsync.prototype.createTask = function (key, taskConfig) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Construct arguments for current task. Order is [passed params, ...resolved required keys]
            var arg = [];
            if (taskConfig.params) {
                arg.push(taskConfig.params);
            }
            (taskConfig.requires || []).forEach(function (dataKey) {
                arg.push(_this.resolvedData[dataKey]);
            });
            taskConfig.task
                .apply(null, arg)
                .then(function (data) {
                // Task succeeded. Stop timeout if required, and start cleanup
                clearTimeout(taskConfig.timeoutObj);
                _this.completeTask(key, data, true);
                resolve(data);
                // Pass errors to the failure callback to stop optional tasks from erroring out
            })
                .catch(function (error) {
                if (taskConfig.optional) {
                    _this.completeTask(key, error);
                    resolve(error);
                }
                else {
                    reject(error);
                }
            });
            if (taskConfig.timeout) {
                taskConfig.timeoutObj = setTimeout(function () {
                    var hasDependencies = false;
                    Object.keys(_this.tasks.waiting).forEach(function (nextTask) {
                        hasDependencies =
                            hasDependencies ||
                                _this.tasks.waiting[nextTask].requires.indexOf(key) >= 0;
                    });
                    // Timed out tasks that have dependencies have to resolve immediately instead of waiting for
                    // the latest possible moment
                    // Also checks if this is the last active task that times out
                    if (hasDependencies ||
                        Object.keys(_this.tasks.active).length <=
                            Object.keys(_this.tasks.timedOut).length + 1) {
                        var err = new Error("Task '".concat(key, "' timed out!"));
                        if (taskConfig.optional) {
                            _this.completeTask(key, err);
                            resolve(err);
                        }
                        else {
                            reject(err);
                        }
                    }
                    else {
                        _this.tasks.timedOut[key] = taskConfig;
                    }
                }, taskConfig.timeout);
            }
        });
    };
    /**
     * Task has finished, either through success or failure. Handles post-task cleanup.
     * Completes the parent batch async if all tasks are determined complete.
     * @param {String} key Key of task that completed
     * @param {Object} result Data from task success, or error if task failed
     * @param {Boolean} succeeded Whether the task succeeded or not
     */
    BatchAsync.prototype.completeTask = function (key, result, succeeded) {
        if (succeeded === void 0) { succeeded = false; }
        // This can happen if a task succeeded after it timed out with dependencies.
        // In this case, it's missed the boat already. Just ignore the success and move on.
        if (!this.tasks.active[key]) {
            return;
        }
        // Store if task completed successfully for chained task success/rejection
        this.tasks.active[key].succeeded = succeeded;
        // Mark task as complete and store returned data if successful, returned error if failed
        this.tasks.resolved[key] = this.tasks.active[key];
        this.resolvedData[key] = result;
        delete this.tasks.active[key];
        delete this.tasks.timedOut[key];
        // The server doesn't output the result of failed optional tasks by default
        if (!succeeded &&
            this.tasks.resolved[key].optional &&
            !this.tasks.resolved[key].silenceOptionalErrors) {
            console.error(result);
        }
        this.initWaitingTasks();
        this.checkAllTasksResolved();
    };
    /**
     * Starts up all currently waiting tasks if their requirements have been met.
     * Fails waiting tasks whose requirements have been met, but failed
     */
    BatchAsync.prototype.initWaitingTasks = function () {
        var _this = this;
        Object.keys(this.tasks.waiting).forEach(function (nextKey) {
            var nextTask = _this.tasks.waiting[nextKey];
            var nextTaskState = {
                ready: true,
                anyParentSuccess: false,
                allParentsSucceeded: true,
            };
            nextTask.requires.forEach(function (requireKey) {
                if (!_this.tasks.resolved[requireKey]) {
                    nextTaskState.ready = false;
                }
                else if (_this.tasks.resolved[requireKey].succeeded) {
                    nextTaskState.anyParentSuccess = true;
                }
                else {
                    nextTaskState.allParentsSucceeded = false;
                }
            });
            // Only run child tasks if all required parents have finished resolving, success or failure
            if (!nextTaskState.ready) {
                return;
            }
            var action = nextTask;
            if (!nextTaskState.allParentsSucceeded) {
                // Overwrite the next task to an instant failure if current task failed and allowSingleParentSuccess is not set
                // See config descriptions for more detailed explanation
                if (!(nextTask.allowSingleParentSuccess && nextTaskState.anyParentSuccess)) {
                    action = {
                        task: function () {
                            return new Promise(function (s, f) {
                                return f(new Error("Precondition not met: ".concat(nextKey)));
                            });
                        },
                        optional: true,
                    };
                }
            }
            // Mark new task as active and spawn it
            _this.tasks.active[nextKey] = action;
            delete _this.tasks.waiting[nextKey];
            _this.createTask(nextKey, action).catch(function (error) { return _this._reject(error); });
        });
    };
    /**
     * Called after a task completes and you've started any new tasks dependent on its data
     * If no tasks are active or the only remaining active tasks are timed out, we're done
     * Resolve successfully with the finished data, or fail if any timed out task was required
     */
    BatchAsync.prototype.checkAllTasksResolved = function () {
        var _this = this;
        if (Object.keys(this.tasks.active).length <=
            Object.keys(this.tasks.timedOut).length) {
            var success_1 = true;
            Object.keys(this.tasks.timedOut).forEach(function (timedKey) {
                if (!success_1) {
                    return;
                }
                var output = new Error("Task '".concat(timedKey, "' timed out!"));
                if (!_this.tasks.timedOut[timedKey].optional) {
                    success_1 = false;
                    _this._reject(output);
                    return;
                }
                _this.resolvedData[timedKey] = output;
                delete _this.tasks.timedOut[timedKey];
            });
            if (success_1) {
                this._resolve(this.resolvedData);
            }
        }
    };
    return BatchAsync;
}());
/**
 * Promise.all, but with options, built-in timeouts, and dependency management.
 * @param {BatchAsyncConfig} config
 * @returns {Promise} Response data for the entire batch after completion
 */
function batchAsync(config) {
    return new BatchAsync(config).promise;
}
exports.batchAsync = batchAsync;
