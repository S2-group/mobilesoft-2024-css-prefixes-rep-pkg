import Cookie from 'js-cookie';
import { v4 } from 'uuid';
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var snippet = function snippet(_ref) {
  var orgId = _ref.orgId,
    _ref$namespace = _ref.namespace,
    namespace = _ref$namespace === void 0 ? 'FS' : _ref$namespace;
  _ref.debug;
  var _ref$host = _ref.host,
    host = _ref$host === void 0 ? 'fullstory.com' : _ref$host,
    _ref$script = _ref.script,
    script = _ref$script === void 0 ? 'edge.fullstory.com/s/fs.js' : _ref$script;
  if (!orgId) {
    throw new Error('FullStory orgId is a required parameter');
  }
  window['_fs_host'] = host;
  window['_fs_script'] = script;
  window['_fs_org'] = orgId;
  window['_fs_namespace'] = namespace;
  (function (m, n, e, t, l, o, g, y) {
    if (e in m) {
      if (m.console && m.console.log) {
        m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');
      }
      return;
    }
    g = m[e] = function (a, b, s) {
      g.q ? g.q.push([a, b, s]) : g._api(a, b, s);
    };
    g.q = [];
    o = n.createElement(t);
    o.async = 1;
    o.crossOrigin = 'anonymous';
    o.src = 'https://' + _fs_script;
    y = n.getElementsByTagName(t)[0];
    y.parentNode.insertBefore(o, y);
    g.identify = function (i, v, s) {
      g(l, {
        uid: i
      }, s);
      if (v) g(l, v, s);
    };
    g.setUserVars = function (v, s) {
      g(l, v, s);
    };
    g.event = function (i, v, s) {
      g('event', {
        n: i,
        p: v
      }, s);
    };
    g.anonymize = function () {
      g.identify(!!0);
    };
    g.shutdown = function () {
      g("rec", !1);
    };
    g.restart = function () {
      g("rec", !0);
    };
    g.log = function (a, b) {
      g("log", [a, b]);
    };
    g.consent = function (a) {
      g("consent", !arguments.length || a);
    };
    g.identifyAccount = function (i, v) {
      o = 'account';
      v = v || {};
      v.acctId = i;
      g(o, v);
    };
    g.clearUserCookie = function () {};
    g.setVars = function (n, p) {
      g('setVars', [n, p]);
    };
    g._w = {};
    y = 'XMLHttpRequest';
    g._w[y] = m[y];
    y = 'fetch';
    g._w[y] = m[y];
    if (m[y]) m[y] = function () {
      return g._w[y].apply(this, arguments);
    };
    g._v = "1.3.0";
  })(window, document, window['_fs_namespace'], 'script', 'user');
};
var fs = function fs() {
  return window[window._fs_namespace];
};
var ensureSnippetLoaded = function ensureSnippetLoaded() {
  var snippetLoaded = !!fs();
  if (!snippetLoaded) {
    throw Error('FullStory is not loaded, please ensure the init function is invoked before calling FullStory API functions');
  }
};
var hasFullStoryWithFunction = function hasFullStoryWithFunction() {
  ensureSnippetLoaded();
  for (var _len = arguments.length, testNames = new Array(_len), _key = 0; _key < _len; _key++) {
    testNames[_key] = arguments[_key];
  }
  return testNames.every(function (current) {
    return fs()[current];
  });
};
var guard = function guard(name) {
  return function () {
    if (window._fs_dev_mode) {
      var message = "FullStory is in dev mode and is not recording: ".concat(name, " method not executed");
      console.warn(message);
      return message;
    }
    if (hasFullStoryWithFunction(name)) {
      var _fs;
      return (_fs = fs())[name].apply(_fs, arguments);
    }
    console.warn("FS.".concat(name, " not ready"));
    return null;
  };
};
var event = guard('event');
var identify = guard('identify');
var shutdown = guard('shutdown');
var _init = function _init(inputOptions, readyCallback) {
  var options = _objectSpread2({}, inputOptions);
  if (fs()) {
    console.warn('The FullStory snippet has already been defined elsewhere (likely in the <head> element)');
    return;
  }
  if (options.recordCrossDomainIFrames) {
    window._fs_run_in_iframe = true;
  }
  if (options.recordOnlyThisIFrame) {
    window._fs_is_outer_script = true;
  }
  if (options.debug === true) {
    if (!options.script) {
      options.script = 'edge.fullstory.com/s/fs-debug.js';
    } else {
      console.warn('Ignoring `debug = true` because `script` is set');
    }
  }
  snippet(options);
  if (readyCallback) {
    fs()('observe', {
      type: 'start',
      callback: readyCallback
    });
  }
  if (options.devMode === true) {
    var message = 'FullStory was initialized in devMode and will stop recording';
    event('FullStory Dev Mode', {
      message_str: message
    });
    shutdown();
    window._fs_dev_mode = true;
    console.warn(message);
  }
};
var initOnce = function initOnce(fn, message) {
  return function () {
    if (window._fs_initialized) {
      if (message) console.warn(message);
      return;
    }
    fn.apply(void 0, arguments);
    window._fs_initialized = true;
  };
};
var init$1 = initOnce(_init, 'FullStory init has already been called once, additional invocations are ignored');

// This function is meant to be used exclusively for generating session ids. Since we only need to disambiguate session
// within a single (cookie_id, website_id and user_id) AND this id is not used to access anything, we use Math.random(),
// which is not cryptographically strong, in place of Crypto.getRandomValues(). Optimizes for compatibility.
const generateRandomString = () => {
  return new Array(5).fill(0).map(() => Math.random().toString(36).slice(-1)).join('');
};
// A SID is composed of the current timestamp and a random string, this lets us sort session by start time, making sure
// we have two distinct identifiers in case 2 sessions are started at the same time. This solution was chosen over using
// uuid v4 or something like ulid, for 2 reasons: the ids are shorter, saving traffic and it allows the lib to remain
// dependecy-free.
const generateSid = () => {
  return Date.now().toString() + '-' + generateRandomString();
};
/**
 * Transform every char in given string that's not alphanumerical or period to underscore
 * as sort of a convention, so topic name are uniform
 */
const cleanName = text => {
  return text.toLowerCase().replace(/[^a-z0-9\.]+/g, '_');
};
// Turns main attributes from a tracking event into a string hash, e.g. "www.page.load"
const getTopic = (event, logToConsole) => {
  const preJoin = [event.category, event.action, event.label].filter(v => {
    return v !== undefined && v !== null;
  });
  const topic = preJoin.join('.').replace(/-/g, '_');
  const clean = preJoin.map(cleanName).join('.');
  if (logToConsole && topic != clean) {
    console.warn(`frontend-tracking: topic was normalized from '${topic}' to '${clean}'`);
  }
  return clean;
};
// Turns main attributes from a tracking event into a shorter string hash, e.g. "www.page"
// Specifically used to keep within Fullstory's cardinality limits for event names
const getShortTopic = (event, logToConsole) => {
  const preJoin = [event.category, event.action].filter(v => {
    return v !== undefined && v !== null;
  });
  const topic = preJoin.join('.').replace(/-/g, '_');
  const clean = preJoin.map(cleanName).join('.');
  if (logToConsole && topic != clean) {
    console.warn(`frontend-tracking: short topic was normalized from '${topic}' to '${clean}'`);
  }
  return clean;
};
// Returns browsers language as 2-char format, e.g. "en" or "de", if readable, else null.
// Gets used as a fallback for the "language" attribute in a tracking event payload, if
// given configuration doesn't provide a custom solution
const getLanguage = () => {
  const lang = navigator.language || navigator.userLanguage;
  if (typeof lang === 'string') {
    return lang.substr(0, 2).toLowerCase();
  }
  return null;
};
/**
 * Based on this array we decide whether to fire tracking events to staging or to
 * production endpoints. If we wouldn't differentiate here, tracking events that
 * come up in development or staging envs would clutter prod endpoints.
 */
const STAGING_HOSTS = ['localhost', 'stable-staging.com', 'jimdosite-stage.com', 'jimdo-platform.net', 'stage.jimdo.systems', 'jimdo-dev-staging.com', 'storybook', 'pv-url' // Maverick Preview URL
];

const browserBeacon = () => navigator.sendBeacon.bind(navigator);
const sendEvent = (endpoint, data, sendBeacon) => {
  const beacon = sendBeacon ?? browserBeacon();
  try {
    beacon(endpoint, data);
  } catch {
    sendEventFallback(endpoint, data);
  }
};
const sendEventFallback = async (endpoint, data) => {
  await fetch(endpoint, {
    method: 'POST',
    body: data,
    headers: {
      'Content-Type': 'application/json'
    },
    mode: 'no-cors',
    credentials: 'omit',
    cache: 'no-cache',
    referrerPolicy: 'origin',
    keepalive: true
  });
};
var objectOmit = omit;

/*
  var obj = {a: 3, b: 5, c: 9};
  omit(obj, ['a', 'c']); // {b: 5}
  omit(obj, a, c); // {b: 5}
  omit(obj, ['a', 'b', 'd']); // {c: 9}
  omit(obj, ['a', 'a']); // {b: 5, c: 9}
*/

function omit(obj, remove) {
  var result = {};
  if (typeof remove === 'string') {
    remove = [].slice.call(arguments, 1);
  }
  for (var prop in obj) {
    if (!obj.hasOwnProperty || obj.hasOwnProperty(prop)) {
      if (remove.indexOf(prop) === -1) {
        result[prop] = obj[prop];
      }
    }
  }
  return result;
}
let hasFullstoryEnabled = false;
const fsTrackingBlacklist = ['cms.text.edit', 'cms.website.save'];
const fsTrackingPropertyBlacklist = ['auto', 'viewportHeight', 'viewportWidth', 'geo', 'userId', 'uiUserId', 'gtm.start', 'eventLabel', 'eventCategory', 'eventAction', 'event', 'language subdomain'];
const isFsTrackingBlacklistedItem = eventName => fsTrackingBlacklist.includes(eventName);
(() => {
  if (typeof window === 'undefined') {
    return;
  }
  window['_fs_ready'] = function () {
    hasFullstoryEnabled = true;
  };
})();
let fullStoryTracker = null;
const makeFullStoryTracker = (waitForConsent, userAccountId) => {
  let hasFullstoryConsent = false;
  waitForConsent(() => {
    hasFullstoryConsent = true;
    if (!hasFullstoryEnabled) {
      init$1({
        orgId: '5F864'
      }, () => {
        if (userAccountId) {
          identify(userAccountId);
        }
      });
      hasFullstoryEnabled = true;
    }
  });
  return (eventName, eventData) => {
    if (!hasFullstoryConsent || !hasFullstoryEnabled) {
      return;
    }
    event(eventName, eventData);
  };
};
// these two constants could be delegated to a config file or env vars
const TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/rich';
const TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/rich';
// Monotonically increasing ticker for sent messages. This allows us to detect if messages went missing or arrived out
// of order
let seq = 0;
// A session ID. The purpose of this ID is to uniquely identify a session, within which the `seq` is supposed to be
// monotmonotonically increasing. The session id gets generated on library load, this should mean, there is one session
// id per: browser, tab, refresh
const TRACKING_SID = generateSid();
const RichTracking = config => event => {
  var _config$getSeedPayloa, _config$getUserAgent, _config$getLanguage, _config$getReferrer, _config$getLocation, _config$userAccountId, _config$websiteId;
  const topic = getTopic(event, config.logToConsole || false);
  const shortTopic = getShortTopic(event, config.logToConsole || false);
  const seedPayload = (config === null || config === void 0 ? void 0 : (_config$getSeedPayloa = config.getSeedPayload) === null || _config$getSeedPayloa === void 0 ? void 0 : _config$getSeedPayloa.call(config)) ?? {};
  const message = {
    userAgent: (config === null || config === void 0 ? void 0 : (_config$getUserAgent = config.getUserAgent) === null || _config$getUserAgent === void 0 ? void 0 : _config$getUserAgent.call(config)) ?? navigator.userAgent,
    isAffiliate: config.isAffiliate && config.isAffiliate(),
    language: (config === null || config === void 0 ? void 0 : (_config$getLanguage = config.getLanguage) === null || _config$getLanguage === void 0 ? void 0 : _config$getLanguage.call(config)) ?? getLanguage(),
    referrer: (config === null || config === void 0 ? void 0 : (_config$getReferrer = config.getReferrer) === null || _config$getReferrer === void 0 ? void 0 : _config$getReferrer.call(config)) ?? document.referrer,
    location: (config === null || config === void 0 ? void 0 : (_config$getLocation = config.getLocation) === null || _config$getLocation === void 0 ? void 0 : _config$getLocation.call(config)) ?? document.location.href,
    ...seedPayload,
    ...event.payload
  };
  const data = {
    anonId: config.anonId(),
    env: config.env,
    userAccountId: config === null || config === void 0 ? void 0 : (_config$userAccountId = config.userAccountId) === null || _config$userAccountId === void 0 ? void 0 : _config$userAccountId.call(config),
    websiteId: config === null || config === void 0 ? void 0 : (_config$websiteId = config.websiteId) === null || _config$websiteId === void 0 ? void 0 : _config$websiteId.call(config),
    message: JSON.stringify(message),
    topic,
    seq: seq++,
    sid: TRACKING_SID
  };
  if (config.logToConsole) {
    console.log(`frontend-tracking: event "${data.topic}" tracked`, message, data);
  }
  if (config !== null && config !== void 0 && config.fullStoryConfig && !fullStoryTracker) {
    const {
      waitForConsent
    } = config.fullStoryConfig();
    fullStoryTracker = makeFullStoryTracker(waitForConsent, data.userAccountId);
  }
  if (fullStoryTracker && !isFsTrackingBlacklistedItem(topic)) {
    const payload = event.payload ? objectOmit(event.payload, fsTrackingPropertyBlacklist) : {};
    fullStoryTracker(shortTopic, {
      env: data.env,
      topic,
      ...payload
    });
  }
  const dataJSON = JSON.stringify(data);
  sendEvent(config.endpoint, dataJSON, config === null || config === void 0 ? void 0 : config.sendBeacon);
};
function getRichTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? TRACKING_ENDPOINT_STAGE : TRACKING_ENDPOINT_PROD;
}
const ANON_TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/anon';
const ANON_TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/anon';
const ANON_TRACKING_SID = generateSid();
generateSid();
/**
 * Tracker factory function, configure it with a session identifer obtained from `generateSid()`
 * it then returns a function that is initially configured with AnonTrackingConfig and then can be used to track to this
 * tracker
 *
 * @param sid the session identifier for the generated tracker
 * @returns - tracker function
 */
const Tracking = sid => {
  // Monotonically increasing ticker for sent messages.
  // This allows us to detect if messages went missing or arrived out of order
  let seq = 0;
  return config => event => {
    var _config$getSeedPayloa2, _config$getLanguage2, _config$getLocation2, _config$websiteId2;
    // e.g. www.page.load
    const topic = getTopic(event, config.logToConsole || false);
    const seedPayload = (config === null || config === void 0 ? void 0 : (_config$getSeedPayloa2 = config.getSeedPayload) === null || _config$getSeedPayloa2 === void 0 ? void 0 : _config$getSeedPayloa2.call(config)) ?? {};
    const message = {
      language: (config === null || config === void 0 ? void 0 : (_config$getLanguage2 = config.getLanguage) === null || _config$getLanguage2 === void 0 ? void 0 : _config$getLanguage2.call(config)) ?? getLanguage(),
      location: (config === null || config === void 0 ? void 0 : (_config$getLocation2 = config.getLocation) === null || _config$getLocation2 === void 0 ? void 0 : _config$getLocation2.call(config)) ?? document.location.href,
      ...seedPayload,
      ...event.payload
    };
    const data = {
      meta: JSON.stringify(message),
      topic,
      seq: seq++,
      sid,
      websiteId: config === null || config === void 0 ? void 0 : (_config$websiteId2 = config.websiteId) === null || _config$websiteId2 === void 0 ? void 0 : _config$websiteId2.call(config)
    };
    if (config.logToConsole) {
      console.log(`frontend-tracking: anonymous event "${data.topic}" tracked`, message, data);
    }
    const dataJSON = JSON.stringify(data);
    sendEvent(config.endpoint, dataJSON, config === null || config === void 0 ? void 0 : config.sendBeacon);
  };
};
/**
 * Provide a tracking config to get an anonymous tracking tracker.
 *
 * This tracker provides 24h sessionalization based on UA and IP address
 *
 * @remarks
 * Compared to DWH tracking the payload doesn't contain userAccountId or anonId (shd cookie),
 * because with such values we could identify a user
 *
 * Also websiteId though present, is used differently. With DWH tracking websiteId is sent in the CMS when the user is editing the website,
 * in Anon tracking it is the website being tracked.
 *
 * @param config - AnonTrackingConfig (endpoint, websiteId, ... etc.)
 * @returns - tracker function
 */
const AnonTracking = Tracking(ANON_TRACKING_SID);
/**
 * Gets tracking endpoint URL by hostname for anonymous tracking
 *
 * @remarks
 * Provide a hostname to decide which endpoint to use (staging vs. prod)
 *
 * @param hostname - e.g. window.location
 * @returns - URL of tracking endpoint
 */
function getAnonTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? ANON_TRACKING_ENDPOINT_STAGE : ANON_TRACKING_ENDPOINT_PROD;
}

/**
 * Finds earliest parent with `data-${attribute}`
 * @param {Node} el
 * @param {Attribute} attribute
 *
 * @returns - HTMLElement or null (if not found)
 */
const earliestParentNodeWith$1 = (el, attribute) => {
  if (el instanceof HTMLElement && el.dataset && el.dataset[attribute]) {
    return el;
  }
  // looks for data attribute on parent recursivly
  if (el.parentNode) {
    return earliestParentNodeWith$1(el.parentNode, attribute);
  }
  return null;
};
/**
 * Tranforms a DOM event into a TrackingEvent interface
 * @param category - e.g. "lp.www"
 * @param eventType - e.g. "click"
 * @param element - HTMLElement, having the data-tracking attribute (e.g. a parental <button> element of a <span>)
 * @param attribute - e.g. "tracking", used to define the eventLabel
 * @param additionalProps - e.g. ['href', 'text']
 *
 * @returns - TrackingEvent
 */
const getTrackingEventForDomEvent = (category, eventType, element, attribute, additionalProps) => {
  const payload = {};
  let eventLabel = element.dataset[attribute] ?? '';
  (additionalProps || []).forEach(prop => {
    var _element$attributes$g;
    payload[prop] = (_element$attributes$g = element.attributes.getNamedItem(prop)) === null || _element$attributes$g === void 0 ? void 0 : _element$attributes$g.value;
  });
  // TODO: check whether this should be "tracking-" instead of "track-"
  // ticket: https://jimplan.atlassian.net/browse/MATO-1516
  // https://github.com/Jimdo/www/blob/master/gatsby/js/cookiebanner/src/addAutomatedTracking.js#L23-L36
  Object.keys(element.dataset).filter(x => x.indexOf('track-') === 0).forEach(trackKey => {
    payload[trackKey.replace('track-', '')] = element.dataset[trackKey];
  });
  return {
    category: category,
    action: eventType,
    label: eventLabel,
    payload // gets populated from two sources:
    // 1. the values of keys from "additionalProps"
    // 2. values from "data-track-" attributes
  };
};
/**
 * Wraps a given track function.
 *
 * @remarks
 * Extracts data from DOM element then it tracks that data
 *
 * @param category - e.g. "lp.www"
 * @param eventType - e.g. "click"
 * @param attribute - e.g. "tracking"
 * @param additionalProps - e.g. ['href', 'text']
 * @param track - which tracking function should be used
 *
 * @returns - a closure that gets triggered on events eg: click, mouseenter
 */
const trackEventType$1 = (category, eventType, attribute, additionalProps, track) => event => {
  // TODO: remove variable shadowing (2 variables named event)
  const {
    target
  } = event;
  if (target instanceof Node) {
    const element = earliestParentNodeWith$1(target, attribute);
    if (element instanceof HTMLElement) {
      const event = getTrackingEventForDomEvent(category, eventType, element, attribute, additionalProps);
      track(event);
    }
  }
};
/**
 * Gets performance metrics from the browser
 *
 * @remarks
 * Example: How long did it take to parse the DOM?
 * TODO: Take care about the deprecation warnings
 *
 * @returns - obj: DOM interactive and completion state
 */
const getPerformanceMetrics$1 = () => {
  let domInteractive = NaN;
  let domComplete = NaN;
  if (performance) {
    const entries = performance.getEntriesByType('navigation');
    if (entries.length > 0) {
      const first = entries[0];
      if (first instanceof PerformanceNavigationTiming) {
        domInteractive = first.domInteractive;
        domComplete = first.domComplete;
      }
    } else if (performance.timing && performance.timing.navigationStart && performance.timing.domInteractive && performance.timing.domComplete) {
      domInteractive = performance.timing.domInteractive - performance.timing.navigationStart;
      domComplete = performance.timing.domComplete - performance.timing.navigationStart;
    }
  }
  return {
    domInteractive,
    domComplete
  };
};
/**
 * Gets query parameters from URL
 *
 * @remarks
 * Example: ?abc=1&def=2 -> {abc: '1', def: '2'}
 * TODO: Check if URL component can do it as well
 *
 * @returns - QueryParams {abc: '1', def: '2'}
 */
const getQueryParams$1 = search => {
  const acc = {};
  if (!search) {
    return acc;
  }
  return search.substr(1).split('&').reduce((acc, param) => {
    const [key, value] = param.split('=');
    acc[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
    return acc;
  }, acc);
};
/**
 * Initializes automated tracking for page events
 *
 * @remarks
 * Example: page load, page unload, page visibility-changes,.. etc.
 *
 * @param category - event category (e.g. lp.www)
 * @param track - tracking function
 * @returns - nothing
 */
const addAutomatedTracking = (category, track) => {
  // skip function during server side rendering
  if (typeof document === 'undefined' || typeof window === 'undefined') {
    return;
  }
  const now = Date.now();
  let maxScrollDepth = 0;
  // wraps the track function with data relevant for the page lifecycle
  // ex: performance metrics, elapsed time, scroll depth
  const trackPage = (label, trackPerformanceMetrics) => {
    const query = getQueryParams$1(window.location.search);
    track({
      category,
      action: 'page',
      label,
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        performance: trackPerformanceMetrics ? getPerformanceMetrics$1() : undefined,
        scrollDepth: window.scrollY,
        referrer: document.referrer,
        maxScrollDepth,
        query,
        auto: true
      }
    });
  };
  if (document.readyState === 'complete') {
    trackPage('complete', false);
  } else if (document.readyState === 'loading') {
    trackPage('loading', false);
  }
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'interactive') {
      trackPage('interactive', false);
    } else if (document.readyState === 'complete') {
      trackPage('complete', false);
    }
  });
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      trackPage('visible', false);
    } else if (document.visibilityState === 'hidden') {
      trackPage('hidden', true);
    }
  });
  window.addEventListener('beforeunload', () => {
    trackPage('unload', true);
  });
  document.body.addEventListener(
  // this tracks all CTAs (using data tracking attributes)
  'click',
  // TODO: additional "text" probably should refer to the text content
  // of a <button> or <a> tag but is always null
  trackEventType$1(category, 'click', 'tracking', ['href', 'text'], track));
  document.querySelectorAll('[data-tracking-onhover]').forEach(e => {
    e.addEventListener('mouseenter', trackEventType$1(category, 'mouseenter', 'tracking', ['href', 'text'], track));
  });
};
const Languages = ["de", "en", "nl", "fr", "es", "it", "ja"];
const SpecialGeoLocations = {
  "/jp": "ja",
  "/au": "en",
  "/nl": "nl",
  "/es": "es",
  "/fr": "fr",
  "/it": "it",
  "/de": "de"
};
// german pages aren't prefixed in Unbounce
// reason: Unbounce was started with DE language, making it the default language ("/")
const UnbounceGeoLocations = {
  "/jp/": "ja",
  "/nl/": "nl",
  "/es/": "es",
  "/fr/": "fr",
  "/it/": "it",
  "/en/": "en"
};
const fallBack = "en";
const unbounceFallBack = "de";
function computeLang() {
  try {
    if (typeof window === "undefined") {
      return fallBack;
    }
    const {
      hostname,
      pathname
    } = window.location;
    if (hostname.indexOf("www-") === 0 || hostname === "jimdo.com" || hostname === "www.jimdo.com" || hostname === "localhost") {
      const match = Object.keys(SpecialGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? SpecialGeoLocations[match] : fallBack;
    }
    // Unbounce pages at go.jimdo.com:
    // German pages aren't prefixed in Unbounce, as the tool was started in german.
    // Therefore DE is the default language
    if (hostname === "go.jimdo.com") {
      const match = Object.keys(UnbounceGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? UnbounceGeoLocations[match] : unbounceFallBack;
    }
    if (hostname === "help.jimdo-dolphin.com" || hostname === "help.jimdo.com" || hostname === "jimdo-partner.zendesk.com") {
      return Languages.find(lang => pathname.startsWith(`/hc/${lang}`)) || fallBack;
    }
    if (hostname === "logo.e.jimdo.com") {
      const i18nextLng = Cookie.get("i18nextLng") || fallBack;
      return Languages.find(lang => i18nextLng.startsWith(lang)) || fallBack;
    }
    if (hostname === "account.e.jimdo.com" || hostname === "account.e.jimdo-stable-staging.com") {
      return Languages.find(lang => pathname.startsWith(`/${lang}/`)) || fallBack;
    }
    const jLang = Cookie.get("jLang") || fallBack;
    return Languages.find(lang => jLang.startsWith(lang)) || fallBack;
  } catch (e) {
    //See: https://stackoverflow.com/questions/64452484/how-can-i-safely-access-caught-error-properties-in-typescript
    const {
      message
    } = e;
    // eslint-disable-next-line no-console
    console.log(`Consent Management: Couldn't determine language: ${message}`);
    return fallBack;
  }
}
const documentBodyLoader = script => {
  return document.body.appendChild(script);
};
const loadScript = function (creator) {
  let {
    loader = documentBodyLoader,
    configurators
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const script = creator();
  const configuredScript = configurators ? configurators.reduce((scriptElement, configurator) => configurator(scriptElement), script) : script;
  loader(configuredScript);
};
const createScriptWithSrc = src => {
  return () => {
    const script = document.createElement("script");
    script.src = src;
    return script;
  };
};
const configureAsyncScript = function () {
  let async = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return scriptElement => {
    scriptElement.async = async;
    return scriptElement;
  };
};
const documentHeadLoader = script => {
  return document.head.appendChild(script);
};
const getGtmDataLayer$1 = () => {
  if (window && window.dataLayer) {
    return window.dataLayer;
  }
  window.dataLayer = [];
  return window.dataLayer;
};
const loadGTM = function (containerId, language) {
  let {
    consentMode
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    consentMode: false
  };
  if (typeof window === "undefined" || !containerId) {
    return;
  }
  const gtmDataLayer = getGtmDataLayer$1();
  function gtag() {
    for (var _len2 = arguments.length, _ = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _[_key2] = arguments[_key2];
    }
    gtmDataLayer.push(arguments);
  }
  if (consentMode) {
    gtag("consent", "default", {
      ad_storage: "denied",
      analytics_storage: "denied",
      wait_for_update: 2000
    });
    gtag("set", "ads_data_redaction", true);
  }
  gtmDataLayer.push({
    "gtm.start": new Date().getTime(),
    event: "gtm.js"
  }, {
    event: "Page Meta",
    "language subdomain": language
  });
  const dl = "";
  const src = `https://www.googletagmanager.com/gtm.js?id=${containerId}${dl}`;
  loadScript(createScriptWithSrc(src), {
    loader: documentHeadLoader,
    configurators: [configureAsyncScript()]
  });
};
const anonTrackingServiceName$1 = ["Jimdo Tracking without cookies", "Jimdo Webanalytics"];
let anonymousTracker;
const setAnonymousTracking = (anonInstance, config) => waitForConsent => {
  waitForConsent(anonTrackingServiceName$1)(() => {
    anonymousTracker = {
      tracker: anonInstance,
      config
    };
  });
};
const constructAnonymousTracker = trackingConfig => AnonTracking(trackingConfig);
const configureAutomatedAnonymousTracking = category => waitForConsent => {
  if (typeof document === "undefined" || typeof window === "undefined") {
    return;
  }
  let interval = null;
  const onAnonymousTracker = tracker => {
    if (document.readyState === "complete") {
      addAutomatedTracking(category, tracker);
    } else {
      window.onload = () => {
        addAutomatedTracking(category, tracker);
      };
    }
  };
  const waitForAnonymousTracker = () => {
    var _anonymousTracker;
    interval = setInterval(waitForAnonymousTracker, 500);
    if ((_anonymousTracker = anonymousTracker) !== null && _anonymousTracker !== void 0 && _anonymousTracker.tracker) {
      onAnonymousTracker(anonymousTracker.tracker);
      if (interval) {
        clearInterval(interval);
      }
    }
  };
  waitForConsent(anonTrackingServiceName$1)(waitForAnonymousTracker);
};
const richTrackingServiceName$1 = ["Jimdo Tracking", "Jimdo Cookie"];
let richTracker;
const constructDwh = trackingConfig => RichTracking(trackingConfig);
const setRichTracking = (richTrackerInstance, config) => waitForConsent => {
  waitForConsent(richTrackingServiceName$1)(() => {
    richTracker = {
      tracker: richTrackerInstance,
      config
    };
  });
};
/**
 * @deprecated Use setRichTracking instead
 */
const setDwh = (richTrackerInstance, config) => {
  console.warn("setDwh is deprecated and will be removed in future releases. Use setRichTracking instead.");
  return setRichTracking(richTrackerInstance, config);
};
const trackRichEvent$2 = event => {
  if (!richTracker) {
    return false;
  }
  const {
    tracker,
    config: {
      filterPayload
    } = {}
  } = richTracker;
  tracker({
    ...event,
    payload: !filterPayload ? event.payload : filterPayload(event.payload)
  });
  return true;
};
const getGtmDataLayer = () => {
  if (window && window.dataLayer) {
    return window.dataLayer;
  }
  window.dataLayer = [];
  return window.dataLayer;
};
const trackEvent$3 = _ref2 => {
  let {
    eventCategory,
    eventAction,
    eventLabel,
    event,
    nonInteraction,
    ...props
  } = _ref2;
  const gtmDataLayer = getGtmDataLayer();
  const trackingData = {
    event: event || "uaevent",
    eventCategory,
    eventAction,
    eventLabel,
    nonInteraction: typeof nonInteraction === "boolean" ? nonInteraction : true,
    ...props
  };
  gtmDataLayer.push(trackingData);
};
var TrackingTypes;
(function (TrackingTypes) {
  TrackingTypes["JIMDO_TRACKING"] = "Jimdo Tracking";
  TrackingTypes["JIMDO_TRACKING_WITHOUT_COOKIES"] = "Jimdo Tracking without cookies";
  TrackingTypes["GTM"] = "GTM";
})(TrackingTypes || (TrackingTypes = {}));
const isOptedIn = dpsName => {
  if (typeof window === "undefined") {
    return false;
  }
  if (!window.__jimdo__ || !window.__jimdo__.CONSENT_STATUS) {
    return false;
  }
  const CONSENT_STATUS = window.__jimdo__.CONSENT_STATUS;
  if (typeof dpsName === "string") {
    var _CONSENT_STATUS$dpsNa;
    return ((_CONSENT_STATUS$dpsNa = CONSENT_STATUS[dpsName]) === null || _CONSENT_STATUS$dpsNa === void 0 ? void 0 : _CONSENT_STATUS$dpsNa.consent) || false;
  } else {
    return dpsName.some(name => {
      var _CONSENT_STATUS$name;
      return ((_CONSENT_STATUS$name = CONSENT_STATUS[name]) === null || _CONSENT_STATUS$name === void 0 ? void 0 : _CONSENT_STATUS$name.consent) || false;
    });
  }
};
const richTrackingServiceName = ["Jimdo Tracking", "Jimdo Cookie"];
const anonTrackingServiceName = ["Jimdo Tracking without cookies", "Jimdo Webanalytics"];
const trackRichEvent$1 = (isOptedIn, queueUnsentEvent) => _ref3 => {
  let {
    category,
    action,
    label,
    payload
  } = _ref3;
  if (!isOptedIn(richTrackingServiceName)) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      action,
      label,
      payload
    }, TrackingTypes.JIMDO_TRACKING);
    return false;
  }
  return trackRichEvent$2({
    category,
    action,
    label,
    payload
  });
};
const trackAnonEvent$1 = (isOptedIn, queueUnsentEvent) => _ref4 => {
  let {
    category,
    anonymousCategory,
    action,
    label,
    payload
  } = _ref4;
  if (!isOptedIn(anonTrackingServiceName) || !anonymousTracker) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      anonymousCategory,
      action,
      label,
      payload
    }, TrackingTypes.JIMDO_TRACKING_WITHOUT_COOKIES);
    return false;
  }
  const {
    tracker,
    config: {
      filterPayload
    } = {}
  } = anonymousTracker;
  tracker({
    category: anonymousCategory || category,
    action,
    label,
    payload: !filterPayload ? payload : filterPayload(payload)
  });
  return true;
};
const trackGtmEvent$1 = (isOptedIn, queueUnsentEvent) => _ref5 => {
  let {
    category,
    action,
    label,
    payload
  } = _ref5;
  if (!isOptedIn("Google Tag Manager")) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      action,
      label,
      payload
    }, TrackingTypes.GTM);
    return false;
  }
  trackEvent$3({
    eventCategory: category,
    eventAction: action,
    eventLabel: label,
    nonInteraction: false,
    ...payload
  });
  return true;
};
const trackEvent$2 = (isOptedIn, queueUnsentEvent) => _ref6 => {
  let {
    category,
    anonymousCategory,
    action,
    label,
    payload
  } = _ref6;
  trackRichEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    action,
    label,
    payload
  });
  trackAnonEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    anonymousCategory,
    action,
    label,
    payload
  });
  trackGtmEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    action,
    label,
    payload
  });
};
const constructTracker = isOptedIn => {
  let unsentEvents = {};
  const getTrackFunction = trackingType => {
    switch (trackingType) {
      case TrackingTypes.JIMDO_TRACKING:
        return trackRichEvent$1;
      case TrackingTypes.JIMDO_TRACKING_WITHOUT_COOKIES:
        return trackAnonEvent$1;
      case TrackingTypes.GTM:
        return trackGtmEvent$1;
    }
  };
  const getUnsentEventId = (event, trackingType) => {
    const normalisedTrackingType = trackingType.toLowerCase().replace(/\s/g, "-");
    return `${normalisedTrackingType}-${event.category}-${event.label}-${event.action}-${Date.now()}`;
  };
  const queueUnsentEvent = (event, trackingType) => {
    var _unsentEvents$trackin;
    const id = getUnsentEventId(event, trackingType);
    if (!unsentEvents[trackingType]) {
      unsentEvents[trackingType] = [];
    }
    (_unsentEvents$trackin = unsentEvents[trackingType]) === null || _unsentEvents$trackin === void 0 ? void 0 : _unsentEvents$trackin.push({
      ...event,
      id
    });
  };
  const sendUnsentEvents = () => {
    const trackingTypes = Object.keys(unsentEvents);
    for (const trackingType of trackingTypes) {
      const events = unsentEvents[trackingType];
      if (!events || events.length === 0) {
        continue;
      }
      const trackFunction = getTrackFunction(trackingType)(isOptedIn);
      let stillUnsentEvents = [];
      for (const event of events) {
        const {
          id,
          ...eventWithoutId
        } = event;
        const isSent = trackFunction(eventWithoutId);
        if (!isSent) {
          stillUnsentEvents.push(event);
        }
      }
      unsentEvents[trackingType] = stillUnsentEvents;
    }
  };
  const scheduleSendingUsentEvents = function () {
    let interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
    let iteration = 0;
    const schedule = () => {
      const timeOut = (iteration + 1) * interval;
      setTimeout(() => {
        sendUnsentEvents();
        iteration++;
        if (iteration < 10) {
          schedule();
        }
      }, timeOut);
    };
    schedule();
  };
  scheduleSendingUsentEvents();
  const eventTracker = trackEvent$2(isOptedIn, queueUnsentEvent);
  const gtmTracker = trackGtmEvent$1(isOptedIn, queueUnsentEvent);
  const richTracker = trackRichEvent$1(isOptedIn, queueUnsentEvent);
  const anonTracker = trackAnonEvent$1(isOptedIn, queueUnsentEvent);
  const createTrackFunction = tracker => (event, eventPropertiesMapper) => {
    const eventProperties = eventPropertiesMapper ? eventPropertiesMapper(event) : event;
    tracker(eventProperties);
  };
  return {
    trackEvent: createTrackFunction(eventTracker),
    trackGtmEvent: createTrackFunction(gtmTracker),
    trackRichEvent: createTrackFunction(richTracker),
    trackAnonEvent: createTrackFunction(anonTracker)
  };
};
const tracker = constructTracker(isOptedIn);

/**
 * Find earliest parent with `data-${attribute}`
 */
const earliestParentNodeWith = (el, attribute) => {
  if (el.dataset && el.dataset[attribute]) {
    return el;
  }
  if (el.parentNode) {
    return earliestParentNodeWith(el.parentNode, attribute);
  }
  return null;
};
const trackEvent$1 = _ref7 => {
  let {
    category,
    anonymousCategory,
    eventType,
    element,
    attribute,
    additionalProps
  } = _ref7;
  if (!element) {
    return;
  }
  const eventLabel = element.dataset[attribute];
  const additionalPropObj = Object.fromEntries(additionalProps.map(x => [x, element[x]]));
  const trackingProps = Object.fromEntries(Object.entries(element.dataset).filter(x => x[0].startsWith("tracking")));
  const payload = Object.assign({}, additionalPropObj, trackingProps);
  tracker.trackEvent({
    action: eventType,
    label: eventLabel,
    payload,
    category,
    anonymousCategory
  }, _ref8 => {
    let {
      action,
      label,
      payload,
      category,
      anonymousCategory
    } = _ref8;
    return {
      action: label,
      label: action,
      payload,
      category,
      anonymousCategory
    };
  });
};
const trackEventType = isOptedIn => _ref9 => {
  let {
    category,
    anonymousCategory,
    eventType,
    attribute,
    additionalProps
  } = _ref9;
  return event => {
    try {
      const {
        target
      } = event;
      if (!target || !(target instanceof HTMLElement)) {
        return;
      }
      const element = earliestParentNodeWith(target, attribute);
      trackEvent$1({
        category,
        anonymousCategory,
        eventType,
        element,
        attribute,
        additionalProps
      });
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error(`E4655: Trying to trackEvent for on ${eventType}: ${err}`);
    }
  };
};
const getPerformanceMetrics = () => {
  let domInteractive = NaN;
  let domComplete = NaN;
  if (performance && performance.timing && performance.timing.navigationStart && performance.timing.domInteractive && performance.timing.domComplete) {
    domInteractive = performance.timing.domInteractive - performance.timing.navigationStart;
    domComplete = performance.timing.domComplete - performance.timing.navigationStart;
  }
  return {
    domInteractive,
    domComplete
  };
};
const makeTrackingVisible = () => {
  if (!Cookie.get("VISUALIZE_TRACKING")) {
    return;
  }
  const style = document.createElement("style");
  style.innerText = `
        [data-tracking]{ border: 4px black dotted!important; }
        [data-tracking][data-tracking-onhover] { border: 4px blue dotted!important; }
        [data-tracking]:hover:before {
            font-size: 12px;
            color: orange;
            margin-right: 12px;
            content: attr(data-tracking);
            text-transform: lowercase;
        }

    `;
  document.head.appendChild(style);
};
const getQueryParams = search => {
  if (!search) {
    return {};
  }
  return search.substr(1).split("&").reduce((acc, param) => {
    const [key, value] = param.split("=");
    acc[key] = value ? decodeURIComponent(value.replace(/\+/g, " ")) : "";
    return acc;
  }, {});
};
const addCustomAutomatedTracking = isOptedIn => _ref10 => {
  let {
    category,
    anonymousCategory
  } = _ref10;
  let alreadyInitialized = false;
  const now = Date.now();
  let maxScrollDepth = 0;
  const trackEventTypeWithOptIn = trackEventType();
  const eventPropertiesMapper = _ref11 => {
    let {
      action,
      label,
      payload,
      category,
      anonymousCategory
    } = _ref11;
    return {
      action: label,
      label: action,
      payload,
      category,
      anonymousCategory
    };
  };
  const onload = () => {
    const query = getQueryParams(window.location.search);
    tracker.trackEvent({
      category,
      anonymousCategory,
      action: "load",
      label: "page",
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepth: window.scrollY,
        maxScrollDepth,
        nonInteraction: true,
        query
      }
    }, eventPropertiesMapper);
    document.body.addEventListener("click", trackEventTypeWithOptIn({
      category,
      anonymousCategory,
      eventType: "click",
      attribute: "tracking",
      additionalProps: ["href", "text"]
    }));
    document.querySelectorAll("[data-tracking-onhover]").forEach(e => {
      if (e) {
        e.addEventListener("mouseenter", trackEventTypeWithOptIn({
          category,
          anonymousCategory,
          eventType: "mouseenter",
          attribute: "tracking",
          additionalProps: ["href", "text"]
        }));
      } else {
        // eslint-disable-next-line no-console
        console.log(`E7480: Could not attach listener to element`, e);
      }
    });
    // Please dont track what is typed because this might autotrack passwords
    document.body.addEventListener("keydown", trackEventTypeWithOptIn({
      category,
      anonymousCategory,
      eventType: "keydown",
      attribute: "tracking",
      additionalProps: ["label"]
    }));
    document.addEventListener("scroll", () => {
      maxScrollDepth = Math.max(window.scrollY, maxScrollDepth);
    }, {
      passive: true
    });
    window.addEventListener("beforeunload", () => {
      tracker.trackEvent({
        category,
        anonymousCategory,
        action: "unload",
        label: "page",
        payload: {
          performance: getPerformanceMetrics(),
          timeSpentOnPageInMS: Date.now() - now,
          scrollDepth: window.scrollY,
          maxScrollDepth,
          nonInteraction: true
        }
      }, eventPropertiesMapper);
    });
    /**
     * Event is fired when user focuses the page
     * happens when tab is changed or user changes
     * to another application and comes back
     */
    window.addEventListener("focus", () => tracker.trackEvent({
      category,
      anonymousCategory,
      action: "focus",
      label: "page",
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepth: window.scrollY,
        maxScrollDepth,
        nonInteraction: true
      }
    }, eventPropertiesMapper));
    window.addEventListener("blur", () => tracker.trackEvent({
      category,
      anonymousCategory,
      action: "blur",
      label: "page",
      payload: {
        performance: getPerformanceMetrics(),
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepthWhileUnloading: window.scrollY,
        maxScrollDepth,
        nonInteraction: true
      }
    }, eventPropertiesMapper));
  };
  return {
    start: () => {
      if (alreadyInitialized) {
        return;
      }
      alreadyInitialized = true;
      if (document.readyState === "complete") {
        onload();
      } else {
        window.onload = onload;
      }
    }
  };
};
const extractQueryParams = () => {
  if (typeof window.location === "undefined" || typeof window.location === "undefined" || !window.location.search) {
    // serverside rendering
    return {};
  }
  const params = window.location.search.replace("?", "").split(/(=|&)/).filter(x => x !== "=" && x !== "&");
  const queryParams = {};
  for (let j = 0; j < params.length; j = j + 2) {
    queryParams[params[j]] = params[j + 1];
  }
  return queryParams;
};
const CREATOR_COOKIE_NAME = "jimdoRefAffiliate";
const unsetOldAffiliateReferrer = () => {
  Cookie.remove(CREATOR_COOKIE_NAME);
};

/**
 * @param {object} queryParams query parameters from url
 * @returns true if the value seems like a correct affiliation link
 */
const isValidAffiliateLink = queryParams => {
  return Boolean(queryParams.irclickid) && Boolean(queryParams.ref) && queryParams.ref.indexOf("imp") === 0;
};
const mapToAffiliateParameters = function () {
  let queryParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    clickId: queryParams.irclickid
  };
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = function () {
  return (r = Object.assign || function (r) {
    for (var t, n = 1, e = arguments.length; n < e; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);
    return r;
  }).apply(this, arguments);
};
var e$1 = [{
  name: "ckies_necessary",
  lifetimeKey: "Y1",
  info: "Confirms that other necessary cookies get set"
}, {
  name: "ckies_functional",
  lifetimeKey: "Y1",
  info: "Opt-out for functional cookies"
}, {
  name: "ckies_performance",
  lifetimeKey: "Y1",
  info: "Opt-out for performance cookies"
}, {
  name: "ckies_marketing",
  lifetimeKey: "Y1",
  info: "Opt-out for marketing/third party/consent based cookies"
}, {
  name: "cookielaw",
  lifetimeKey: "Y1",
  info: "If this cookie is present, the cookie banner shall no longer be displayed because the user has accepted it."
}, {
  name: "userLoggedIn",
  lifetimeKey: "SESSION",
  info: "Indicates that the user is logged in."
}, {
  name: "trs",
  lifetimeKey: "M1",
  info: "Cookie for Affiliate tracking"
}, {
  name: "languageRedirect",
  lifetimeKey: "SESSION",
  info: "Saves the information if the visitor was redirected based on his / her browser language setting."
}, {
  name: "_bb_optout",
  lifetimeKey: "Y1",
  info: "This cookie contains the information that the user does not want to participate in A/B tests with Bunchbox."
}, {
  name: "shd",
  lifetimeKey: "Y1",
  info: "A cookie to identify a returning visitor\t"
}, {
  name: "csrftoken",
  lifetimeKey: "SESSION",
  info: "Mechanism for the secure transmission of data"
}, {
  name: "sessionid",
  lifetimeKey: "SESSION",
  info: "Session cookie for Jimdo Dashboard"
}, {
  name: "ClickAndChange",
  lifetimeKey: "SESSION",
  info: "Session Cookie for Creator CMS"
}, {
  name: "PHPSESSID",
  lifetimeKey: "SESSION",
  info: "Session Cookie for a.jimdo.com"
}, {
  name: "jLang",
  lifetimeKey: "SESSION",
  info: "The chosen language"
}, {
  name: "lang",
  lifetimeKey: "SESSION",
  info: "The chosen language"
}, {
  name: "ga-opt-out",
  lifetimeKey: "Y20",
  info: "Opt-out for Google Analytics and Google Optimize"
}, {
  name: "logo_id",
  lifetimeKey: "SESSION",
  info: "Contains the ID of the user created logo"
}, {
  name: "fullstory_integration",
  lifetimeKey: "D1",
  info: "This cookie is used to enable a consistent integration of the service FullStory throughout the products of Jimdo for the visitor."
}, {
  name: "jimdoRefAffiliate",
  lifetimeKey: "M2",
  info: "This cookie contains information on the users affiliate referrer (if any)"
}, {
  name: "jimdoExperiment",
  lifetimeKey: "M1",
  info: "This cookie contains the A/B test variant that the user takes part in and the functionality related to the test, to make sure that the user’s experience is consistent on our landing pages."
}, {
  name: "accept_tos_during_signup",
  lifetimeKey: "H12",
  info: "This cookie marks the acceptance of the Jimdo Account Terms of Service. (Social Signup only)"
}, {
  name: "accept_newsletter_during_signup",
  lifetimeKey: "H12",
  info: "This cookie marks the newsletter consent during Social signup."
}, {
  name: "user_account_id",
  lifetimeKey: "Y1",
  info: "ID of the Jimdo User Account."
}];

/**
 * @preserve
 * Checks whether given cookie name is part of the allowlist, and,
 * if so, returns that cookie (Cookie). If not, returns undefined
 * @param name - The name of the cookie
 */
var t = function (r) {
    return e$1.find(function (n) {
      return n.name === r;
    });
  },
  o$1 = function (n) {
    return void 0 !== t(n);
  },
  i$1 = function (n) {
    return o$1(n) ? Cookie.get(n) : void 0;
  };
var e = [{
    key: "SESSION",
    value: 0,
    description: "Session"
  }, {
    key: "H3",
    value: .125,
    description: "3 hours"
  }, {
    key: "H6",
    value: .25,
    description: "6 hours"
  }, {
    key: "H12",
    value: .5,
    description: "12 hours"
  }, {
    key: "D1",
    value: 1,
    description: "1 day"
  }, {
    key: "W1",
    value: 7,
    description: "1 week"
  }, {
    key: "M1",
    value: 30,
    description: "1 month"
  }, {
    key: "M2",
    value: 60,
    description: "2 months"
  }, {
    key: "Y1",
    value: 365,
    description: "1 year"
  }, {
    key: "Y2",
    value: 730,
    description: "2 years"
  }, {
    key: "Y20",
    value: 7300,
    description: "20 years"
  }],
  i = function (i) {
    return e.find(function (e) {
      return e.key === i;
    });
  };
var o = function () {
    var o;
    return "undefined" != typeof process && void 0 !== process.env ? "production" === process.env.NODE_ENV : null !== (o = null === window || void 0 === window ? void 0 : window.location.hostname.includes("jimdo.com")) && void 0 !== o && o;
  },
  n = function (o, n) {
    if (!o) throw new Error(n);
    console.error(n);
  };

/**
 * @preserve
 * Compares cookie name to central allowlist and fetches expires information from it.
 * If the desired cookie name isn't part of that list yet,
 * you should use the js-cookie lib or add the desired cookie name to the allowlist:
 * https://github.com/Jimdo/jimdo-cookies#how-to-update-the-list
 * @param name - The name of the cookie
 * @param value - The value for that cookie
 * @param options - Options object: sameSite, path, domain, secure, but *no* expires
 */
var s = function (s, m, p) {
  void 0 === p && (p = {});
  var f = o(),
    a = t(s);
  if (a) {
    p.hasOwnProperty("expires") && (n(f, "Pls don't provide a custom value for cookie expiration! We fetch the proper value from the allowlist automatically for you."), delete p.expires);
    var d = p,
      u = i(a.lifetimeKey);
    "SESSION" !== a.lifetimeKey && u && (d = r(r({}, d), {
      expires: u.value
    })), Cookie.set(s, m, d);
  } else n(f, 'No cookie "' + s + '" found in allowlist. Check for typo or simply add it!');
};
function getRootDomain() {
  if (typeof window === "undefined" || typeof window.location === "undefined") {
    return "";
  }
  if (window.location.hostname === "localhost") {
    // Local dev
    return window.location.hostname;
  }
  if (window.location.hostname.indexOf("fastly.net") > 0) {
    // CDN
    return window.location.hostname;
  }
  return "." + window.location.hostname.split(".").slice(-2).join(".");
}

/**
 * Cookie is for this service: https://github.com/jimdo/affiliate-reporter
 */
const TRS_COOKIE_NAME = `trs`;
const TRS_COOKIE_VERSION = 1;
const setTRSCookie = value => {
  s(TRS_COOKIE_NAME, `v${TRS_COOKIE_VERSION}.` + btoa(JSON.stringify(value)), {
    domain: getRootDomain() || ".jimdo.com",
    path: "/",
    sameSite: "Lax"
  });
};
const setImpactAffiliationCookie = () => {
  const queryParams = extractQueryParams();
  if (isValidAffiliateLink(queryParams)) {
    setTRSCookie(mapToAffiliateParameters(queryParams));
    unsetOldAffiliateReferrer();
  }
};
const unsetNewAffiliateCookie = () => {
  Cookie.remove(TRS_COOKIE_NAME);
};
const getAffId = (str, regExp) => {
  const [, cookie] = (str || "").match(regExp) || [];
  return cookie;
};
const AFFILIATE_REGEX_HASH = /ref=(a?\d+)/;
const AFFILIATE_REGEX_QUERY = /[&|?]ref=(a?\d+)/;
const getOldAffIdFromUrl = _ref12 => {
  let {
    hash,
    search
  } = _ref12;
  if (AFFILIATE_REGEX_HASH.test(hash)) {
    return getAffId(hash, AFFILIATE_REGEX_HASH);
  }
  if (AFFILIATE_REGEX_QUERY.test(search)) {
    return getAffId(search, AFFILIATE_REGEX_QUERY);
  }
  return null;
};
const setOldAffiliateReferrer = () => {
  if (typeof window !== `undefined`) {
    const affiliateId = getOldAffIdFromUrl(window.location);
    if (affiliateId) {
      s(CREATOR_COOKIE_NAME, affiliateId, {
        path: "/",
        domain: getRootDomain(),
        sameSite: "Lax"
      });
      return affiliateId;
    }
  }
  return null;
};
const setCreatorAffiliationCookie = () => {
  if (getOldAffIdFromUrl(window.location)) {
    setOldAffiliateReferrer();
    unsetNewAffiliateCookie();
  }
};
const getShdCookie = () => i$1("shd");

/**
 * Refreshes live time of cookie
 */
const setShdCookie = () => {
  const shd = getShdCookie() || v4();
  s("shd", shd, {
    domain: getRootDomain() || ".jimdo.com",
    path: "/",
    sameSite: "Lax"
  });
  return shd;
};
const reload = () => {
  if (!window || !window.location) {
    return;
  }
  window.location.reload();
};
const removeCookies = cookieNames => {
  cookieNames.forEach(cookieName => {
    Cookie.remove(cookieName);
  });
};
const JIMDO_CONSENT_CHANGED_EVENT_NAME = "JIMDO_CONSENT_CHANGED";
const JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME = "JIMDO_CONSENT_BANNER_INTERACTION";
const onConsentChange = _ref13 => {
  let {
    onAllow,
    onDeny
  } = _ref13;
  if (typeof window === "undefined") {
    return;
  }
  window.addEventListener(JIMDO_CONSENT_CHANGED_EVENT_NAME, event => {
    const {
      detail: {
        dpsName,
        consent,
        userInteraction
      }
    } = event;
    if (consent) {
      onAllow === null || onAllow === void 0 ? void 0 : onAllow(dpsName, userInteraction);
    } else {
      onDeny === null || onDeny === void 0 ? void 0 : onDeny(dpsName, userInteraction);
    }
  });
};
const waitForConsent = isOptedIn => dpsName => onAllow => {
  if (isOptedIn(dpsName)) {
    onAllow();
  } else {
    onConsentChange({
      onAllow: allowedDpsName => {
        if (typeof dpsName === "string" && allowedDpsName !== dpsName) {
          return;
        } else if (!dpsName.includes(allowedDpsName)) {
          return;
        }
        onAllow();
      }
    });
  }
};
const withConsent = isOptedIn => function () {
  const waitForConsentWithOptIn = waitForConsent(isOptedIn);
  for (var _len3 = arguments.length, loaders = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    loaders[_key3] = arguments[_key3];
  }
  for (const loader of loaders) {
    loader(waitForConsentWithOptIn);
  }
};
const getAnonId = () => getShdCookie() || setShdCookie();
const getUserAccountId = () => i$1("user_account_id");
const onConsentBannerInteraction = onInteraction => {
  if (typeof window === "undefined") {
    return;
  }
  window.addEventListener(JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME, event => {
    const {
      detail: {
        type,
        layer
      }
    } = event;
    onInteraction(type, layer);
  });
};
const trackConsentBannerInteraction = consentBannerInteractionsTrackCategory => (type, layer) => {
  tracker.trackRichEvent({
    category: consentBannerInteractionsTrackCategory,
    action: "consent_banner",
    label: type,
    payload: {
      layer
    }
  });
};
const init = _ref14 => {
  let {
    gtmContainerId,
    gtmConsentMode = false,
    customAutomatedTrackingSettings,
    getDpsCookieNames,
    consentBannerInteractionsTrackCategory
  } = _ref14;
  const language = computeLang();
  setShdCookie();
  onConsentChange({
    onAllow: dpsName => {
      switch (dpsName) {
        case "Affiliate":
          setImpactAffiliationCookie();
          setCreatorAffiliationCookie();
          break;
      }
    },
    onDeny: (dpsName, userInteraction) => {
      if (dpsName === "Affiliate") {
        unsetNewAffiliateCookie();
        unsetOldAffiliateReferrer();
        return;
      }
      if (!userInteraction) {
        return;
      }
      removeCookies(getDpsCookieNames(dpsName));
      reload();
    }
  });
  if (consentBannerInteractionsTrackCategory) {
    onConsentBannerInteraction(trackConsentBannerInteraction(consentBannerInteractionsTrackCategory));
  }
  loadGTM(gtmContainerId, language, {
    consentMode: gtmConsentMode
  });
  if (customAutomatedTrackingSettings) {
    const {
      category,
      anonymousCategory
    } = customAutomatedTrackingSettings;
    makeTrackingVisible();
    addCustomAutomatedTracking()({
      category,
      anonymousCategory
    }).start();
  }
};
const withConsentOptIn = withConsent(isOptedIn);
const waitForConsentOptIn = waitForConsent(isOptedIn);
const {
  trackEvent,
  trackGtmEvent,
  trackAnonEvent,
  trackRichEvent
} = tracker;
const addApiToWindow = () => {
  if (typeof window !== `undefined`) {
    window.__jimdo__ = {
      ...(window.__jimdo__ || {}),
      initTracking: init,
      withConsentOptIn,
      waitForConsentOptIn,
      setAnonymousTracking,
      configureAutomatedAnonymousTracking,
      setDwh,
      setRichTracking,
      constructDwh,
      constructAnonymousTracker,
      getTrackingEndpoint: getRichTrackingEndpoint,
      getRichTrackingEndpoint,
      getAnonTrackingEndpoint,
      getAnonId,
      getUserAccountId,
      trackRichEvent,
      trackAnonEvent,
      trackGtmEvent
    };
  }
};
addApiToWindow();
export { configureAutomatedAnonymousTracking, getAnonId, getUserAccountId, init, setAnonymousTracking, setDwh, setRichTracking, trackAnonEvent, trackEvent, trackGtmEvent, trackRichEvent, waitForConsentOptIn, withConsentOptIn };