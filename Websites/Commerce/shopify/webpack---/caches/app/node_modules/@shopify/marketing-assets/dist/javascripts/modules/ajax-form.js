'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var I18n = require('../global/i18n');
var A11y = require('../global/a11y-helpers');
var utils = require('../helpers/utils');
var FormsAPI = require('./forms-api');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var I18n__default = /*#__PURE__*/_interopDefaultLegacy(I18n);
var A11y__default = /*#__PURE__*/_interopDefaultLegacy(A11y);
var FormsAPI__default = /*#__PURE__*/_interopDefaultLegacy(FormsAPI);

const ERROR_CONTAINER_SELECTOR = '.marketing-form__messages';
const SUCCESS_MESSAGE_SELECTOR = '.marketing-form__ajax-success';
const HIDDEN_ON_SUCCESS_SELECTOR = '.marketing-input-wrapper, .marketing-form__hidden-on-success, .marketing-form__messages';
const REQUIRED_FIELD_SELECTOR = 'input[required], select[required], textarea[required]';
const FORM_LOADING_CLASS = 'marketing-form--is-loading';
const VISIBLE_CLASS = 'js-is-visible';
const HIDDEN_CLASS = 'js-is-hidden';
const DEFAULT_I18N_SCOPE = 'forms.errors';
const GLOBAL_ERRORS = ['invalid', 'required', 'generic', 'throttled'];

function errorKey(error) {
  const key = Object.keys(error.error)[0];
  return GLOBAL_ERRORS.indexOf(key) === -1 ? error.field : 'global';
}
/**
 * Generic AJAX form
 *
 * @param {Element} el The form element
 * @param {Array} [validations] array of validation objects: each object must have
  a `name` matching the <input> element's name, and a `fn` that returns an
 object
 * @param {Object} [options] configuration options
 * @param {String} [options.i18nScope='forms.errors'] The `i18n` scope for where error keys live
 * @param {Boolean} [options.json=false] Whether to request a JSON response from the server
 * @param {Function} [options.onError] A function that is invoked when the form submission fails
 * @param {Function} [options.onSuccess] A function that is invoked after the form submission was successful
 * @class AjaxForm
 * @namespace ShopifyMarketing
 * @constructor
 */


function AjaxForm(form, validations = [], options = {}) {
  this.form = form;
  this.validations = this.collectValidations(validations);
  this.form.addEventListener('submit', this.handleSubmit.bind(this));
  this.messages = this.form.querySelectorAll(ERROR_CONTAINER_SELECTOR);
  this.success = this.form.querySelector(SUCCESS_MESSAGE_SELECTOR);
  this.url = this.form.action;
  this.method = this.form.method;
  this.errors = [];
  this.options = options;
  this.i18nScope = this.options.i18nScope || DEFAULT_I18N_SCOPE;
}
/**
 * Collect Validations
 * @method collectValidations
 * @param {array} validations initial array of validations passed to constructor
 * @return {array} initial array concatenated with validations extracted from
 * required fields
 */


AjaxForm.prototype.collectValidations = function (validations = []) {
  return Array.from(this.form.querySelectorAll(REQUIRED_FIELD_SELECTOR)).map(el => ({
    name: el.name,
    fn: el.type === 'checkbox' ? FormsAPI__default.validateCheckboxPresent : FormsAPI__default.validatePresent
  })).concat(validations);
};
/**
 * The submit handler runs when the form is submitted.
 *
 * @method handleSubmit
 * @param {Event} evt event object returned from event handler
 */


AjaxForm.prototype.handleSubmit = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default(function* (evt) {
    const form = this.form;
    const fields = utils.formToObject(form);
    form.classList.add(FORM_LOADING_CLASS);
    evt.preventDefault();
    this.errors = this.validateFields(fields);

    if (this.errors.length) {
      this.displayErrors();
      form.classList.remove(FORM_LOADING_CLASS);
    } else {
      yield this.sendData(fields);
    }
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Send data to endpoint specified by the form's action attribute. Ensure that
 * the form action has appropriate headers set for handling CORS responses
 * if the action is cross-origin.
 *
 * @method sendData
 * @param {Object} data object to be sent to server
 * @param {Object} headers
 * @return {Deferred}
 */


AjaxForm.prototype.sendData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default(function* (data, headers = {}) {
    const dataToSend = new FormData();
    Object.entries(data).forEach(([key, value]) => {
      dataToSend.append(key, value);
    });

    if (this.options.json) {
      headers.accept = 'application/json';
    }

    try {
      const response = yield fetch(this.url, {
        credentials: 'include',
        method: this.method,
        body: dataToSend,
        headers
      });
      const result = yield this.options.json ? response.json() : response.text();

      if (response.ok) {
        this.handleSuccess(result);
      } else {
        this.handleError(result);
      }
    } catch (error) {
      this.handleError(error);
    } finally {
      this.form.classList.remove(FORM_LOADING_CLASS);
    }
  });

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Handles when the form submission was successful, responsible for displaying
 * success messages, tracking success and invoking the `onSuccess` handler (if specified).
 *
 * @method handleSuccess
 * @param {Object} data Response object from the server
 */


AjaxForm.prototype.handleSuccess = function (data) {
  this.displaySuccess();
  this.trackSuccess();

  if (utils.isFunction(this.options.onSuccess)) {
    this.options.onSuccess.call(this, data);
  }
};
/**
 * Handles when the form submission failed, responsible for displaying error
 * messages, tracking errors and invoking the `onError` handler (if specified).
 *
 * @method handleError
 * @param {Object} data Response object from the server
 */


AjaxForm.prototype.handleError = function (data) {
  let errorObject;

  if (data !== null && data !== void 0 && data.field && data !== null && data !== void 0 && data.error) {
    errorObject = data;
  } else {
    errorObject = {
      field: 'global',
      error: {
        generic: true
      }
    };
  }

  this.errors = [errorObject];
  this.trackError();
  this.displayErrors();

  if (utils.isFunction(this.options.onError)) {
    this.options.onError.call(this, data);
  }
};
/**
 * Validate fields and returns an array of error objects
 *
 * @method validateFields
 * @param {object} fields key-value pairs of form data
 * @return {array}
*/


AjaxForm.prototype.validateFields = function (fields) {
  return this.validations.map(validation => {
    const error = validation.fn(fields[validation.name]);

    if (Object.keys(error).length === 0) {
      return null;
    }

    return {
      field: validation.name,
      error
    };
  }).filter(Boolean);
};
/**
 * Validate fields and sets `this.errors`.
 *
 * @deprecated Replaced by `validateFields`
 * @method validate
 * @param {object} fields key-value pairs of form data
 * @return {void}
*/


AjaxForm.prototype.validate = function (fields) {
  this.errors = this.validateFields(fields);
};
/**
 * Display the error state.
 *
 * @method displayErrors
 */


AjaxForm.prototype.displayErrors = function () {
  [...this.messages].forEach(el => {
    el.innerHTML = '';
  });
  this.errors.forEach(error => {
    let message;

    if (error.field === 'global') {
      message = [...this.messages].pop();
    } else {
      const inputField = this.form.querySelector(`[name="${error.field}"]`);
      const errorContainerID = inputField.getAttribute('aria-describedby');
      message = this.form.querySelector(`#${errorContainerID}`);
    }

    if (message) {
      this.errorTemplate(error).forEach(errorEl => message.prepend(errorEl));
    }
  });
  this.focusError(this.errors[0]);
};
/**
 * Display the success state.
 *
 * @method displaySuccess
 */


AjaxForm.prototype.displaySuccess = function () {
  this.form.querySelectorAll(HIDDEN_ON_SUCCESS_SELECTOR).forEach(elem => elem.classList.add(HIDDEN_CLASS));

  if (this.success) {
    this.success.classList.add(VISIBLE_CLASS);
    A11y__default.prototype.pageLinkFocus(this.success);
  }
};
/**
 * Given an error object, construct a `<span>` that contains the error message.
 *
 * @method errorTemplate
 * @param {object} error error object of format `{ error: { invalid: true }, field: 'name' }`
 * @return {array} array of DOM elements
*/


AjaxForm.prototype.errorTemplate = function (error) {
  return Object.keys(error.error).map(key => {
    const span = document.createElement('span');
    const scope = `${errorKey(error)}.${key}`;
    const translation = I18n__default.t(`${this.i18nScope}.${scope}`, {
      err: error.error,
      defaults: [{
        scope: `${DEFAULT_I18N_SCOPE}.${scope}`
      }]
    });
    span.classList.add('error');
    span.textContent = translation;
    return span;
  });
};
/**
 * Focus on the form element associated with the given error object
 *
 * @method focusError
 * @param {object} error
 * @return {DOMElement} The input field that was focused.
 */


AjaxForm.prototype.focusError = function (error) {
  if (!error || error.field === 'global') {
    return null;
  }

  const focusedField = this.form.querySelector(`[name="${error.field}"]`);
  focusedField.focus();
  return focusedField;
};
/**
 * Track the successful submission of the form. This a no-op method and should
 * be implemented by your subclass, or handled in the `onSuccess` handler
 *
 * @method trackSuccess
 */


AjaxForm.prototype.trackSuccess = function () {}; // eslint-disable-line no-empty-function

/**
 * Track the errors raised from form submission. This a no-op method and should
 * be implemented by your subclass, or handled in the `onError` handler
 *
 * @method trackError
 */


AjaxForm.prototype.trackError = function () {}; // eslint-disable-line no-empty-function

exports.default = AjaxForm;
