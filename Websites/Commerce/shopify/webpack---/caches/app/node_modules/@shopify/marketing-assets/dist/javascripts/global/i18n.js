'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var utils = require('../helpers/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);

class I18n {
  /**
   * The I18n class helps translate strings using a translation dictionary, and
   * optionally some global constants. It's designed to be similar to the
   * Rails I18n API.
   *
   * @class I18n
   * @constructor
   * @param {Object} [options] configuration options
   * @param {Object} [options.data]
   *   An object where keys are the scope, and the values are either a nested
   *   object, or a string.
   * @param {Object} [options.globals]
   *   An object that represents constants, where the keys and values are only
   *   strings. Useful for site constants, eg. `trial_length` or `total_stores`.
   *   These values can be interpolated into translation strings, eg.
   *   `"Enjoy your %{trial_length} day trial"`.
   */
  constructor({
    data,
    globals
  }) {
    this.data = data || {};
    this.globals = globals || {};
  }
  /**
   * Checks if the locals object contains a `count` key indicating that may
   * require pluralization. Requires `translations` to contain keys of `one`,
   * `zero` and `other` to work.
   *
   * @see https://guides.rubyonrails.org/i18n.html#pluralization
   * @static
   * @method needsPluralize
   * @param  {object} translations
   *   An object of translation data, keys represent scope, values are strings
   * @param  {object} locals
   *   Local data about this translation, in this case, a `count` key
   * @return {boolean}
   *   True if the translation needs to handle pluralization, false otherwise
   */


  static needsPluralize(translations, locals = {}) {
    return utils.isObject(translations) && typeof locals.count !== 'undefined';
  }
  /**
   * Returns the pluralization key given the count value.
   *
   * @static
   * @method getPluralizeKey
   * @param  {object}   translations
   *   An object of translation data, keys represent scope, values are strings
   * @param  {integer}  count
   *   An integer representing "how many"
   * @return {string}
   *   The key to use for translation, can be `zero` (optional), `one` or `other`
   */


  static getPluralizeKey(translations, count) {
    let key = count === 1 ? 'one' : 'other';

    if (count === 0 && utils.isObject(translations) && translations.hasOwnProperty('zero')) {
      key = 'zero';
    }

    return key;
  }
  /**
   * Given a scope, and optionally some `locals` data, return the translated
   * string. Unlike the Rails i18n API, this does not support bulk, namespace
   * or lazy lookups. There is support for pluralization and defaults though.
   *
   * @see retry()
   * @method translate
   * @throws {Error} If scope is not found in the translation data.
   * @param  {string} scope
   *   The scope is a dot delimited string, eg `forms.label`, which will look
   *   for a key `forms`, that has a nested key `label` in the translation
   *   data given to the `i18n` instance
   * @param  {object} locals
   *   An object that contains information that may change the scope used
   *   for translation. Supports pluralization (`count`), interpolation
   *   and `defaults` (see `retry()`)
   * @return {string}
   *   The translated value for the given scope
   */


  translate(scope, locals = {}) {
    const allTranslations = _objectSpread__default(_objectSpread__default({}, this.globals), locals);

    const scopes = scope.split('.');
    let ret = this.data;
    let defaults = [];

    if (locals.hasOwnProperty('defaults')) {
      defaults = locals.defaults;
      delete locals.defaults;
    }

    try {
      // Traverse through the translation data one "scope" at a time
      for (let i = 0, ii = scopes.length; i < ii; i++) {
        ret = ret[scopes[i]];
      } // No key? Throw.


      if (typeof ret === 'undefined') {
        throw new ReferenceError();
      } // Do we need to change the key to look up the translation?


      if (I18n.needsPluralize(ret, locals)) {
        ret = ret[I18n.getPluralizeKey(ret, locals.count)];
      } // Translate string, handling interpolation if required.


      if (Object.keys(allTranslations).length) {
        return utils.template(ret, allTranslations);
      } else {
        return ret;
      }
    } catch (error) {
      // Support retry logic if there are defaults.
      while (typeof ret === 'undefined' && defaults.length) {
        ret = this.retry(defaults.shift());
      }

      if (ret) {
        return ret;
      }

      throw new Error(`failed to translate key ${scope}`);
    }
  }
  /**
   * Retry is used when attempting to resolve an unknown translation scope. It
   * mirrors the API provided by the `i18n-js` package. Accepts an object that
   * contains either `message` or `scope` key. `scope` will attempt to use
   * `translate` to resolve the given `scope` value. `message` will simply
   * return string value.
   *
   * @private
   * @method retry
   * @param  {object} attempt
   *   An object with `message` or `scope` keys.
   * @param  {object} locals
   *   An object that contains information that may change the scope used
   *   for translation. Supports pluralization (`count`) and interpolation.
   * @return {string|undefined}
   *   The translated value for the given scope, or `undefined`.
   */


  retry(attempt, locals) {
    if (attempt.hasOwnProperty('message')) {
      return attempt.message;
    } else if (attempt.hasOwnProperty('scope')) {
      try {
        return this.translate(attempt.scope, locals);
      } catch (err) {// Silent catch, we can just try the next default.
      }
    }

    return undefined;
  }
  /**
   * Alias of `translate`.
   *
   * @method t
   * @see `translate`
   */


  t(scope, locals) {
    return this.translate(scope, locals);
  }

}

var i18n = new I18n(window.I18n || {});

exports.default = i18n;
