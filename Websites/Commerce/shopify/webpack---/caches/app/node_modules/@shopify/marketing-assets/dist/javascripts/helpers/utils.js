'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const templateRegexp = /%\{(.+?)\}/g;
let idCounter = 0;
/**
 * @class ShopifyMarketing.Fn
 */

/**
 * Given a `string` that may contain placeholders, replace them with
 * the values from the `data` object. Placeholders look like
 * `%{number_of_cats}`, which would be replaced by the key
 * `number_of_cats` in `data`. If a placeholder does not exist in
 * `data`, it will remain in the `string`.
 *
 * @method template
 * @param  {string} string
 * @param  {object} data
 * @return {string}
 *  String with placeholders replaced with values.
 */

function template(string, data) {
  const matches = string.match(templateRegexp);

  if (matches) {
    return matches.reduce((res, match) => {
      const key = match.replace(/%{(.*)}/, '$1');

      if (data.hasOwnProperty(key)) {
        return res.replace(match, data[key]);
      }

      return res;
    }, string);
  }

  return string;
}
/**
 * Debounce the given function, where it will only be called once until the
 * `wait` period has passed. `wait` is in milliseconds. The period can be
 * skipped by passing the third argument, `immediate` as `true`.
 *
 * @method  debounce
 * @param  {function} fn
 * @param  {integer}  wait
 * @param  {boolean}  immediate
 * @return {function}
 */

function debounce(fn, wait, immediate = false) {
  let timeout;
  return function (...args) {
    const self = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = null;

      if (!immediate) {
        fn.apply(self, args);
      }
    }, wait);

    if (immediate && !timeout) {
      fn.apply(self, args);
    }
  };
}
/**
 * Given a `HTMLFormElement`, return it's data as a raw object.
 *
 * @param  {HTMLFormElement} form
 * @return {Object}
 */

function formToObject(form) {
  const formData = new FormData(form);
  return Array.from(formData).reduce((memo, [key, value]) => {
    if (memo[key]) {
      if (!memo[key].push) {
        memo[key] = [memo[key]];
      }

      memo[key].push(value || '');
    } else {
      memo[key] = value || '';
    }

    return memo;
  }, {});
}
/**
 * Throttle the given function to run at most once every `limit`, where `limit`
 * is in milliseconds. If `enableTrailing` is set to true it also makes one last
 * call to the given `fn` after a additional 50ms wait period if the throttled fn
 * was called in the last `limit` wait period but not after.
 *
 * @method  throttle
 * @param  {function} fn
 * @param  {integer}  limit
 * @param  {boolean}  enableTrailing
 * @return {function}
 */

function throttle(fn, limit, enableTrailing = false) {
  let wait = false;
  let isTrailing;
  let trailingTimeout;
  return function () {
    if (wait) {
      isTrailing = true;
      return;
    }

    if (enableTrailing && isTrailing) {
      isTrailing = false;
      clearTimeout(trailingTimeout);
    }

    fn.call();
    wait = true;
    setTimeout(() => {
      wait = false;

      if (enableTrailing) {
        trailingTimeout = setTimeout(() => {
          fn.call();
        }, limit);
      }
    }, limit);
  };
}
/**
 * Determine if the given value is a function.
 *
 * @method isFunction
 * @param  {any}  value
 * @return {boolean}
 */
// || false is for an IE 11 bug
// https://github.com/jashkenas/underscore/issues/1621#issuecomment-43777159

function isFunction(value) {
  return typeof value === 'function' || false;
}
/**
 * Determine if the given value is an object.
 *
 * @method isObject
 * @param  {any}  value
 * @return {boolean}
 */

function isObject(value) {
  const type = typeof value;
  return value != null && type === 'object';
}
/**
 * Given a prefix, returns a unique string by incrementing an integer and
 * appending it to the prefix.
 *
 * @method uniqueId
 * @param  {string} prefix
 * @return {string}
 */

function uniqueId(prefix) {
  ++idCounter;
  return `${prefix}${idCounter}`;
}
/**
 * Returns a function that ensures the given function can only called once.
 *
 * @method once
 * @param  {function} fn
 * @return {function}
 */

function once(fn) {
  let called = false;
  let result;
  return function (...args) {
    if (!called) {
      result = fn.apply(this, args);
    }

    called = true;
    return result;
  };
}
/**
 * Determines if the browser prefers reduced motion. Use this to provide
 * an accessible experience to all users by perhaps not animating transitions.
 *
 * @method prefersReducedMotion
 * @return {boolean}
 */

function prefersReducedMotion() {
  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}
/**
 * Picks and returns a subset of keys from an object
 *
 * @method pick
 * @param  {Object} obj the object that you want to pick keys from
 * @param  {Array} keys the keys that you want to pick from the object
 * @return {Object}
 */

function pick(obj, keys) {
  return keys.reduce((accumulator, key) => {
    if (key in obj) {
      accumulator[key] = obj[key];
    }

    return accumulator;
  }, {});
}
/**
 * Determines if a click event or URL matches the location
 * of the current page
 *
 * @method isLinkToCurrentPage
 * @param {string|URL} URL of page to test against current location
 * @return {boolean}
 */

function isLinkToCurrentPage(link) {
  // Return false if no link is passed
  if (!link) {
    return false;
  } // Return false if the link is not a valid URL


  try {
    // eslint-disable-next-line no-new
    new URL(link);
  } catch (error) {
    return false;
  }

  const formatUrl = url => {
    // Remove hashes
    const hashless = url.href.split('#')[0]; // Remove trailed slashes

    return hashless.replace(/\/$/, '');
  };

  const newURL = new URL(link);
  const currentPage = new URL(window.location.href);
  return formatUrl(newURL) === formatUrl(currentPage);
}
const Fn = {
  debounce,
  formToObject,
  isLinkToCurrentPage,
  isObject,
  once,
  pick,
  prefersReducedMotion,
  template,
  throttle,
  uniqueId
};

exports.debounce = debounce;
exports.default = Fn;
exports.formToObject = formToObject;
exports.isFunction = isFunction;
exports.isLinkToCurrentPage = isLinkToCurrentPage;
exports.isObject = isObject;
exports.once = once;
exports.pick = pick;
exports.prefersReducedMotion = prefersReducedMotion;
exports.template = template;
exports.throttle = throttle;
exports.uniqueId = uniqueId;
