'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var A11y = require('../global/a11y-helpers');
var keyCodes = require('../global/keycodes');
var EventEmitter = require('../helpers/event-emitter');
var utils = require('../helpers/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var A11y__default = /*#__PURE__*/_interopDefaultLegacy(A11y);
var keyCodes__default = /*#__PURE__*/_interopDefaultLegacy(keyCodes);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

const DRAWER_EVENTS = {
  beforeClose: 'before_closed',
  beforeOpen: 'before_opened',
  closed: 'closed',
  open: 'opened'
};
/**
 * Slide-out drawer element
 *
 * @param {string} id ID of drawer element
 * @param {string} position which direction drawer slides out from ("right" or "left")
 * @param {object} [options] optional configuration object
 * @param {string} [options.close='.js-drawer-close'] selector for element to trigger drawer close on click
 * @param {string} [options.open='.js-drawer-open-' + position] selector for element to trigger drawer open on click
 * @param {string} [options.openClass='js-drawer-open'] class applied to body element when drawer is open
 * @param {string} [options.dirOpenClass='js-drawer-open' + position] class applied to body element when drawer is open indicating position of drawer
 * @param {number} [options.transitionLength=500] maximum time in milliseconds for the drawer to spend in "transitioning" state, should match CSS transition length + 100ms
 * @class Drawer
 * @namespace ShopifyMarketing
 * @constructor
*/

class Drawer extends EventEmitter__default {
  constructor(id, position, options) {
    super();
    const defaults = {
      close: '.js-drawer-close',
      open: `.js-drawer-open-${position}`,
      openClass: 'js-drawer-open',
      dirOpenClass: `js-drawer-open-${position}`,
      transitioningClass: 'js-drawer--is-transitioning',
      transitionLength: 500
    };
    this.drawer = document.getElementById(id);

    if (!this.drawer) {
      // Avoid throwing an error here as Drawer is created on mist pages (via Nav)
      // and some pages do not have the required Drawer markup (e.g. Free Trial pages)
      return;
    }

    this.config = _objectSpread__default(_objectSpread__default({}, defaults), options);
    this.drawerToggles = [...document.querySelectorAll(this.config.open), ...document.querySelectorAll(this.config.close)];
    this.position = position;
    this.isOpen = false;
    this.hasOpenedOnce = false;
    this.nodes = {
      parent: document.body,
      page: document.getElementById('PageContainer') || document.body
    };
    this.elementToRefocusOnClose = null;
    this.pendingTransitionFallback = null;
    this.init();
  }
  /**
   * Emits the standard drawer event via EventEmitter.emit
   * @method emitDrawerEvent
   * @param {String} eventName the name for this event - should be one of DRAWER_EVENTS
   * @param {Event} evt initial user event that invoked the current event handler
  */


  emitDrawerEvent(eventName, evt) {
    this.emit(eventName, {
      event: evt,
      drawerHasOpenedOnce: this.hasOpenedOnce
    });
  }
  /**
   * Binds methods and sets up event listeners
   * @method init
  */


  init() {
    this._onDrawerOpenInteraction = this._onDrawerOpenInteraction.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onDrawerBodyClick = this._onDrawerBodyClick.bind(this);
    this._onDrawerToggle = this._onDrawerToggle.bind(this);
    this._onDrawerTransitionEnd = this._onDrawerTransitionEnd.bind(this);
    this.drawer.addEventListener('keydown', this._onKeyDown);
    this.drawer.addEventListener('click', this._onDrawerBodyClick);
    this.drawer.addEventListener('transitionend', this._onDrawerTransitionEnd);
    this.drawerToggles.forEach(toggle => {
      toggle.addEventListener('click', this._onDrawerToggle);
    });
  }
  /**
   * Toggles the drawer state
   * @method toggle
   * @param {Event} evt - initial event that invoked the toggle method
  */


  toggle(evt) {
    this.beforeDrawerStateChange(evt);
    this.doDrawerStateChange(evt);
    this.afterDrawerStateChange();
  }
  /**
   * Toggles the drawer state
   * @method open
   * @param {Event} evt - initial event that invoked the open method
  */


  open(evt) {
    this.toggle(evt);
  }
  /**
   * Toggles the drawer state
   * @method close
   * @param {Event} evt - initial event that invoked the toggle method
  */


  close(evt) {
    this.toggle(evt);
  }
  /**
   * Prepares the drawer for upcoming transition in state by emitting before_ events and making drawer visible
   * @method beforeDrawerStateChange
   * @param {Event} evt - initial user event that invoked the toggle event
  */


  beforeDrawerStateChange(evt) {
    // Add transitioning class to ensure visibility through transition
    this.drawer.classList.add(this.config.transitioningClass);
    /* eslint-disable babel/no-unused-expressions */
    // Force a redraw on the drawer otherwise the transition doesn't happen
    // Presently, this force redraw only seems necessary in Safari

    this.drawer.offsetHeight;
    /* eslint-enable babel/no-unused-expressions */

    const eventName = this.isOpen ? DRAWER_EVENTS.beforeClose : DRAWER_EVENTS.beforeOpen;
    this.emitDrawerEvent(eventName, evt);
  }
  /**
   * Updates drawer internal state and applies opened classes.
   * Also sets up a timeout in case transitionend cleanup does not occur
   * @method doDrawerStateChange
   * @param {Event} evt - initial user event that invoked the toggle event via event handler
  */


  doDrawerStateChange(evt) {
    this.isOpen = !this.isOpen;
    this.hasOpenedOnce = this.hasOpenedOnce || this.isOpen;
    this.nodes.parent.classList.toggle(this.config.openClass);
    this.nodes.parent.classList.toggle(this.config.dirOpenClass); // We rely on transitionend to cleanup some classes and fire events, but it is unreliable,
    // so have a fallback that the actual event listener will clear if the real event is fired

    this.pendingTransitionFallback = setTimeout(() => {
      this._onDrawerTransitionEnd(evt);
    }, this.config.transitionLength);
  }
  /**
   * Updates event listeners, focus and aria attributes after the drawer has changed state
   * @method afterDrawerStateChange
  */


  afterDrawerStateChange() {
    this.updateFocus();
    this.updateAriaAttributes();
    this.updateDrawerOpenListeners();
  }
  /**
   * Updates the toggles associated with this drawer to have correct aria attribute based on this.isOpen
   * based on the value of this.isOpen
   * @method updateAriaAttributess
  */


  updateAriaAttributes() {
    this.drawerToggles.forEach(toggle => {
      if (toggle.getAttribute('aria-expanded')) {
        toggle.setAttribute('aria-expanded', this.isOpen);
      }
    });
  }
  /**
   * Update focus based on drawer state
   * @method updateFocus
  */


  updateFocus() {
    if (this.isOpen) {
      // Trap focus in drawer
      A11y__default.prototype.trapFocus(this.drawer);
      this.drawer.focus();
    } else {
      // Unfocus drawer and return focus to the element that opened the drawer
      if (document.activeElement) {
        document.activeElement.blur();
      }

      A11y__default.prototype.removeTrapFocus(this.drawer);

      if (this.elementToRefocusOnClose) {
        this.elementToRefocusOnClose.focus();
      }
    }
  }
  /**
   * Updates 'drawer open' event handlers after a transition event, adding or removing depending on current state
   * @method updateDrawerOpenListeners
  */


  updateDrawerOpenListeners() {
    if (this.isOpen) {
      this.addDrawerOpenListeners();
    } else {
      this.removeDrawerOpenListeners();
    }
  }
  /**
   * Adds event listeners used when drawer is open
   * @method addDrawerOpenListeners
  */


  addDrawerOpenListeners() {
    // Lock scrolling on mobile
    this.nodes.page.addEventListener('touchmove', this._onDrawerOpenInteraction);
    this.nodes.page.addEventListener('click', this._onDrawerOpenInteraction);
  }
  /**
   * Removes event listeners that were for drawer open on drawer close
   * @method addDrawerOpenListeners
  */


  removeDrawerOpenListeners() {
    this.nodes.page.removeEventListener('touchmove', this._onDrawerOpenInteraction);
    this.nodes.page.removeEventListener('click', this._onDrawerOpenInteraction);
  }
  /**
   * Toggles drawer state if open/closed buttons pressed
   * @method _onDrawerToggle
   * @private
   * @param {Event} evt event object passed to event handler
  */


  _onDrawerToggle(evt) {
    evt.stopPropagation(); // Update the source of the click if drawer is currently closed, we'll focus to this on close

    if (!this.isOpen) {
      this.elementToRefocusOnClose = evt.currentTarget;
    }

    this.toggle(evt);
  }
  /**
   * Close drawer if ESC key pressed
   * @method _onKeyDown
   * @private
   * @param {Event} evt event object returned from event handler
  */


  _onKeyDown(evt) {
    if (this.isOpen && evt.keyCode === keyCodes__default.ESCAPE) {
      this.toggle();
    }
  }
  /**
   * Handler that fires when a user clicks or touchscrolls while the drawer is open
   * Prevents user from touchscrolling when drawer open, and allows clicks outside drawer to close it
   * @method _onDrawerOpenInteraction
   * @private
   * @param {Event} evt event object from click/touchscroll event
  */


  _onDrawerOpenInteraction(evt) {
    if (evt.target.classList.contains('drawer')) ; else {
      // User is interacting outside drawer
      if (evt.type === 'click') {
        this.toggle();
      }

      evt.preventDefault();
      evt.stopPropagation();
    }
  }
  /**
   * Removes event listeners on drawer close
   * @method _addDrawerOpenListeners
   * @private
   * @param {Event} evt event object from initiating event. Will be 'click' event if called via fallback or 'transitionend' otherwise.
  */


  _onDrawerTransitionEnd(evt) {
    if (!this.pendingTransitionFallback) {
      // We have already invoked this method for this transition
      return;
    } // Reset the fallback


    clearTimeout(this.pendingTransitionFallback);
    this.pendingTransitionFallback = null;
    this.drawer.classList.remove(this.config.transitioningClass);
    const eventName = this.isOpen ? DRAWER_EVENTS.open : DRAWER_EVENTS.closed;
    this.emitDrawerEvent(eventName, evt);
  }
  /**
   * Event that's run when the drawer body is clicked on
   * @method _onDrawerBodyClick
   * @private
   * @param {Event} evt event object returned from click event
  */


  _onDrawerBodyClick(evt) {
    // Close drawer if the URL is linking to the current page
    if (!utils.isLinkToCurrentPage(evt.target.href)) {
      return;
    } // The user isn't expecting to close the drawer, so don't refocus on the open trigger


    this.toggle(evt); // Blur away from nav button since the user wants to view this page

    if (document.activeElement) {
      document.activeElement.blur();
    } // Prevent page from reloading


    evt.preventDefault();
  }

}

exports.default = Drawer;
