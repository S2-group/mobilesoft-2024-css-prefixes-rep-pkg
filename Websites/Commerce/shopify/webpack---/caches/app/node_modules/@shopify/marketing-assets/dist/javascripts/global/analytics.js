'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var monorail = require('@shopify/monorail');
var utils = require('../helpers/utils');
var QueryString = require('../helpers/querystring');
var URLHelper = require('../helpers/url');
var Config = require('./config');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var QueryString__default = /*#__PURE__*/_interopDefaultLegacy(QueryString);
var URLHelper__default = /*#__PURE__*/_interopDefaultLegacy(URLHelper);
var Config__default = /*#__PURE__*/_interopDefaultLegacy(Config);

const monorailSchema = 'marketing_page_event/2.0';
const dataSelectors = '[data-event-category], [data-ga-event], [data-ga-category]';

function trackGA(eventData) {
  if (!utils.isFunction(window._gaUTracker)) {
    return;
  }

  const customNamespace = Config__default.get('customGoogleAnalyticsNamespace', null);

  const trackingData = _objectSpread__default(_objectSpread__default({}, Config__default.get('defaultGoogleAnalyticsEventData', null)), eventData);

  window._gaUTracker('send', 'event', trackingData);

  if (customNamespace) {
    window._gaUTracker(`${customNamespace}.send`, 'event', trackingData);
  }
}

class Analytics {
  /**
   * The Analytics component assists with tracking events with Google Analytics,
   * Tealium and Monorail.
   *
   * @class Analytics
   * @constructor
   */
  constructor() {
    this.appEnv = process.env.NODE_ENV;
    this.monorail = this._createMonorailProducer(this.appEnv);
    this.canonicalLink = document.querySelector('link[rel=\'canonical\']');
    this.tealiumQueue = [];
    this.tealiumQueueInterval = null;

    this._trackElementsWithAnalyticsDataAttributes();
  }
  /**
   * Use track when you want to record an event to Google Analytics, Tealium or
   * Monorail.
   *
   * @see https://developers.google.com/analytics/devguides/collection/analyticsjs/events#event_fields
   * @method track
   * @param  {string|object}  category
   *  Typically the object that was interacted with, or a full eventData object.
   * @param  {string}  action
   *  The type of interaction
   * @param  {string}  label
   *  Useful for categorizing events
   * @param  {integer} value
   *  A numeric value associated with the event
   * @param  {boolean} [nonInteraction=false]
   *  Whether this event will count a user interaction or not, affects bounce rate calculations
   * @param  {Object} [tealiumContext={}]
   *  Keyed object containing additional data for this event to be sent to Tealium only
   *  Accepted fields are `emailAddress, shopName`
   */


  track(category, action, label, value, nonInteraction = false, tealiumContext = {}) {
    let eventData;

    if (utils.isObject(category)) {
      eventData = category;
    } else {
      eventData = {
        eventCategory: category,
        eventAction: action,
        eventLabel: label,
        eventValue: !isNaN(Number(value)) && value || undefined,
        nonInteraction
      };
    }

    eventData = Object.keys(eventData).reduce((result, key) => {
      const val = eventData[key];

      if (val) {
        result[key] = val;
      }

      return result;
    }, {});
    this.trackTealium(eventData, tealiumContext);
    this.monorailProducer(eventData);
    return trackGA(eventData);
  }
  /**
   * Produce event info to Monorail using the Monorail producer.
   *
   * Note: `user_token` will only be available if trekkie token is set
   *
   * @method monorailProducer
   */


  monorailProducer({
    eventAction = '',
    eventCategory = '',
    eventLabel = '',
    nonInteraction = false,
    eventValue
  }) {
    if (!window.analytics) {
      return;
    }

    const {
      /* eslint-disable babel/camelcase */
      utm_medium = '',
      utm_source = ''
      /* eslint-enable babel/camelcase */

    } = QueryString__default.parse(URLHelper__default.querystring(window.location.href));
    window.analytics.ready(() => {
      const {
        appName,
        visitToken,
        uniqToken,
        microSessionId,
        experiment_variation_id // eslint-disable-line babel/camelcase

      } = window.analytics.trekkie.defaultAttributes; // make sure eventValue is a number
      // 0 is falsy, so short hand would be tough here

      const eventValueNumber = Number(eventValue);
      const apiEventValue = isNaN(eventValueNumber) ? undefined : eventValueNumber;
      const data = {
        schemaId: monorailSchema,
        payload: {
          /* eslint-disable babel/camelcase */
          canonical_url: this.canonicalLink ? this.canonicalLink.getAttribute("href") : "",
          environment: this.appEnv,
          event_action: eventAction.toString(),
          event_category: eventCategory.toString(),
          event_label: eventLabel.toString(),
          event_noninteraction: nonInteraction,
          event_value: apiEventValue,
          experiment_variation_id,
          page_category: "",
          page_language: document.documentElement.lang,
          page_url: window.location.href,
          pageview_id: microSessionId,
          project: appName,
          session_token: visitToken,
          user_token: uniqToken,
          utm_medium: utm_medium.toString(),
          utm_source: utm_source.toString()
          /* eslint-enable babel/camelcase */

        }
      };
      this.monorail.produce(data);
    });
  }
  /**
   * Event data will be passed to Tealium via the `window.utag.link()` function.
   *
   * In the event that the analytics libraries aren't ready yet, the event will be queued.
   * An interval (set at 500ms) will check for analytics "ready" and process the queue.
   *
   * In testing we found that the tealium bundle took between 200ms(local, wired) to 1s(3G-simulated)
   * to download, however (locally) we don't start seeing "dropped" events until the bundle
   * takes around 700ms to download.
   *
   * With an interval of 500ms, this code should run 1 to 3 times before tealium is ready
   * and the interval is cleared.
   *
   *
   * Note: `user_token` will only be available if trekkie token is set
   *
   * @method trackTealium
   * @param  {object}  eventData
   *  An object containing the relevant data for this event.
   *  Required keys: `eventAction, eventCategory, eventLabel, eventValue`
   * @param  {Object} [context={}]
   *  Keyed object containing additional data for this event
   *  Accepted fields are `emailAddress, shopName`
   */


  trackTealium(eventData, context = {}) {
    if (this._analyticsLibrariesReady()) {
      this._fireTealiumEvent(eventData, context);
    } else {
      this.tealiumQueue.push({
        eventData,
        context
      });

      if (!this.tealiumQueueInterval) {
        this.tealiumQueueInterval = setInterval(() => {
          if (!this._analyticsLibrariesReady()) {
            return;
          }

          clearInterval(this.tealiumQueueInterval);

          while (this.tealiumQueue.length) {
            const event = this.tealiumQueue.shift();

            this._fireTealiumEvent(event.eventData, event.context);
          }
        }, 500);
      }
    }
  }

  _analyticsLibrariesReady() {
    return window.utag && window.analytics;
  }

  _fireTealiumEvent(eventData, context) {
    // Ensure only valid context keys have been provided
    const validEventContextFields = ['emailAddress', 'shopName'];

    if (utils.isObject(context) && this.appEnv !== 'production') {
      Object.keys(context).forEach(key => {
        if (!validEventContextFields.includes(key)) {
          // eslint-disable-next-line no-console
          console.warn(`Invalid tealium context key provided: ${key}`);
        }
      });
    }

    window.analytics.ready(() => {
      var _window$utag$data, _window$utag_data;

      const {
        appName: project = '',
        experiment_variation_id // eslint-disable-line babel/camelcase

      } = window.analytics.trekkie.defaultAttributes;
      window.utag.link({
        /* eslint-disable babel/camelcase */
        event_action: eventData.eventAction || '',
        event_category: eventData.eventCategory || '',
        event_label: eventData.eventLabel || '',
        event_non_interaction: 'false',
        event_value: eventData.eventValue || '',
        event_context: context,
        project,
        tealium_event: 'event',
        user_token: window.analytics.user().traits().uniqToken || '',
        compliance_zone: ((_window$utag$data = window.utag.data) === null || _window$utag$data === void 0 ? void 0 : _window$utag$data.compliance_zone) || ((_window$utag_data = window.utag_data) === null || _window$utag_data === void 0 ? void 0 : _window$utag_data.compliance_zone) || 'unknown',
        experiment_variation_id
        /* eslint-enable babel/camelcase */

      });
    });
  }
  /**
   * Track clicks from elements that have data attributes added from the
   * `event_tracking_data` helper (eg. `event-category`, `event-page`,
   * `event-action`, `event-label` and `event-value`).
   *
   * For historical reasons, this also supports legacy `ga-event`,
   * `ga-category`, `ga-action`, `ga-label` and `ga-value` data attributes.
   *
   * @see https://github.com/Shopify/marketing_assets/blob/master/app/views/marketing_assets/styleguide/developer-kit/70-analytics/event_tracking_helper.md
   * @method _trackElementsWithAnalyticsDataAttributes
   * @private
   */


  _trackElementsWithAnalyticsDataAttributes() {
    document.body.addEventListener('click', evt => {
      const elWithData = evt.target.closest(dataSelectors);

      if (!elWithData) {
        return false;
      }

      const data = elWithData.dataset;

      if (data.eventCategory) {
        return this.track({
          eventAction: data.eventAction,
          eventCategory: data.eventCategory,
          eventLabel: data.eventLabel,
          eventValue: data.eventValue ? parseFloat(data.eventValue, 10) : undefined
        });
      } // `ga-` prefix is deprecated and should no longer be used


      if (data.gaEvent || data.gaCategory) {
        return this.track(data.gaEvent || data.gaCategory, data.gaAction, data.gaLabel, data.gaValue);
      }

      return false;
    });
  }
  /**
   * Creates a Monorail producer interface for the appropriate environment.
   *
   * @method _createMonorailProducer
   * @private
   * @param {string} env
   * @return {Monorail}
   */


  _createMonorailProducer(env) {
    if (this.monorail) {
      return this.monorail;
    }

    const isProduction = env === 'production' || env === 'staging';
    return isProduction ? monorail.Monorail.createHttpProducer({
      production: true
    }) : monorail.Monorail.createLogProducer({
      debugMode: true
    });
  }

}

var analytics = new Analytics();

exports.default = analytics;
