'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var keyCodes = require('../global/keycodes');
var utils = require('../helpers/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var keyCodes__default = /*#__PURE__*/_interopDefaultLegacy(keyCodes);

/**
 * Simple hover-triggered popover
 * @param {$DOM element} el Element hovering over which should trigger the popover.
 * @param {Object} [options] optional configuration object
 * @param {String} [options.position=bottom] position of popover relative to trigger element. top/right/bottom/left.
 * @param {String} [options.align=left] how the popover aligns to the trigger element. top/right/bottom/left/center.
 * @param {Boolean} [hasFlyout] lets the popover know that it should consider additional space for another popover
 * @param {Function} [options.onShow] a callback function for when the popover is shown
 * @param {Function} [options.onHide] a callback function for when the popover is hidden
 * @class Popover
 * @namespace ShopifyMarketing
 * @constructor
*/

class Popover {
  constructor($el, options) {
    this.$el = $el;
    const defaults = {
      position: 'bottom',
      align: 'left',
      hasFlyout: false
    };
    const dataset = utils.pick(this.$el.dataset, ['position', 'align']);
    this.config = _objectSpread__default(_objectSpread__default(_objectSpread__default({}, defaults), options), dataset);
    this.$popover = this.$el.querySelector('.popover');
    this.$trigger = this.$el.querySelector('.popover__trigger');
    this.$html = document.documentElement;
    ['show', 'hide', '_onClick', '_onKeyup', '_onFocusout', '_onMousedown', '_onHtmlClick', '_onResize'].forEach(method => {
      this[method] = this[method].bind(this);
    });
    this.$trigger.addEventListener('click', this._onClick);
    this.$el.addEventListener('keyup', this._onKeyup);
    this.$el.addEventListener('focusout', this._onFocusout);
    this.$el.addEventListener('mousedown', this._onMousedown);
    window.addEventListener('resize', utils.debounce(this._onResize, 250));
    this.isOpen = false;
    this.init();
  }

  init() {
    this.popoverId = utils.uniqueId('Popover');
    this.$popover.setAttribute('id', this.popoverId);
    this.$trigger.setAttribute('aria-expanded', 'false');
    this.$trigger.setAttribute('aria-controls', this.popoverId);
    this.$trigger.setAttribute('aria-current', 'location');
  }
  /**
   * Show the popover
   * @method show
  */


  show() {
    if (this.isOpen) {
      return;
    }

    if (!this.placeIsSet) {
      this._updatePlace();

      this.placeIsSet = true;
    }

    this.$html.addEventListener('click', this._onHtmlClick);
    this.$el.classList.add('is-active');
    this.$trigger.setAttribute('aria-expanded', 'true');
    this.isOpen = true;

    if (this.config.onShow) {
      this.config.onShow.call(this);
    }
  }
  /**
   * Hide the popover
   * @method hide
  */


  hide() {
    if (!this.isOpen) {
      return;
    }

    this.$html.removeEventListener('click', this._onHtmlClick);
    this.$el.classList.remove('is-active');
    this.$trigger.setAttribute('aria-expanded', 'false');
    this.isOpen = false;

    if (this.config.onHide) {
      this.config.onHide.call(this);
    }
  }
  /**
   * Toggle the popover between show and hide
   * @method toggle
  */


  toggle() {
    if (this.isOpen) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * The method that runs when the users clicks on the popover. It captures the
   * state of mousedown for the duration of the event cycle. This is a bit of a
   * trick to ensure that focusOut doesn't close the popover if the user is
   * clicking on it.
   * @private
   * @method _onMousedown
  */


  _onMousedown() {
    this.mousedown = true;
    setTimeout(() => {
      this.mousedown = false;
    });
  }
  /**
   * The method that runs when the user focuses on something. It closes
   * the popover if they're focusing outside of the popover.
   * @private
   * @method _onFocusout
  */


  _onFocusout() {
    if (this.mousedown) {
      return;
    }

    setTimeout(() => {
      if (this.$el.contains(document.activeElement)) {
        return;
      }

      this.hide();
    });
  }
  /**
   * The method that runs when the user clicks on the trigger. It toggles
   * the state of the popover.
   * @private
   * @method _onClick
  */


  _onClick() {
    setTimeout(() => {
      this.toggle();
    });
  }
  /**
   * The method that runs when the user clicks on the html tag. It closes the
   * popover if the popover isn't clicked on.
   * @private
   * @method _onHtmlClick
   * @param {Object} evt the event object
  */


  _onHtmlClick(evt) {
    if (this.$el.contains(evt.target)) {
      return;
    }

    this.hide();
  }
  /**
   * The method that runs when the user uses the keyboard. It toggles on SPACE,
   * and closes on ESCAPE.
   * @private
   * @method _onKeyup
   * @param {Object} evt the event object
  */


  _onKeyup(evt) {
    switch (evt.keyCode) {
      case keyCodes__default.SPACE:
        if (evt.target !== this.$trigger) {
          break;
        }

        evt.preventDefault();
        evt.stopPropagation();
        this.toggle();
        break;

      case keyCodes__default.ESCAPE:
        this.hide();
        this.$trigger.focus();
    }
  }
  /**
   * The method that runs when the user resize the browser.
   * @private
   * @method _onResize
  */


  _onResize() {
    this._updatePlace();
  }
  /**
   * Stores the Bounding Client Rectangles of the wrapper and popover
   * on the popover object. It requires the popover to be rendered in order to
   * get proper calculations.
   * @private
   * @method _updateRects
  */


  _updateRects() {
    if (!this.isOpen) {
      this.$popover.classList.add('popover--measure');
    }

    this.wrapperRect = this.$el.getBoundingClientRect();
    this.popoverRect = this.$popover.getBoundingClientRect();

    if (!this.isOpen) {
      this.$popover.classList.remove('popover--measure');
    }
  }
  /**
   * Figures out if the popover can be placed in a certain area without falling
   * outside of the viewport.
   * @private
   * @method _canPlace
   * @param {String} position the position of the popover
   * @param {String} align the alignment of the popover
   * @return {Boolean} Whether it can be placed or not
  */


  _canPlace(position, align) {
    const spaceOnRight = window.innerWidth - this.wrapperRect.left;
    const spaceOnLeft = this.wrapperRect.left;
    const popoverWidth = this.popoverRect.width + (this.config.hasFlyout ? this.popoverRect.width : 0);
    const popoverOverflow = (this.popoverRect.width - this.wrapperRect.width) / 2;

    switch (position) {
      case 'left':
        return popoverWidth < spaceOnLeft;

      case 'right':
        return popoverWidth < spaceOnRight;
    }

    switch (align) {
      case 'left':
        return popoverWidth < spaceOnRight;

      case 'right':
        return popoverWidth < spaceOnLeft;

      case 'center':
        return popoverOverflow < spaceOnLeft && popoverOverflow < spaceOnRight;
    }

    return true;
  }
  /**
   * Figures out the most ideal place for the popover to render so that it can
   * fit within the viewport
   * @private
   * @method _findBestPlace
   * @return {Array} Array of the position and alignment
  */


  _findBestPlace() {
    let position;

    if (this.config.position === 'top' || this.config.position === 'bottom') {
      position = this.config.position;
    } else {
      position = 'bottom';
    }

    if (this._canPlace(position, 'left')) {
      return [position, 'left'];
    } else if (this._canPlace(position, 'right')) {
      return [position, 'right'];
    } else {
      return [position, 'center'];
    }
  }
  /**
   * Places the popover content relative to the trigger
   * @private
   * @method _place
   * @param {String} position the position of the popover
   * @param {String} align the alignment of the popover
  */


  _place(position, align) {
    const positionMatch = this.$popover.className.match(/popover--position-[^ ]*/);
    const alignMatch = this.$popover.className.match(/popover--align-[^ ]*/);

    if (positionMatch) {
      this.$popover.classList.remove(positionMatch[0]);
    }

    if (alignMatch) {
      this.$popover.classList.remove(alignMatch[0]);
    }

    this.$popover.classList.add(`popover--position-${position}`);
    this.$popover.classList.add(`popover--align-${align}`);
  }
  /**
   * Checks whether the popover will fit in the viewport, and moves it if
   * necessary
   * @private
   * @method _updatePlace
  */


  _updatePlace() {
    this._updateRects();

    const {
      position,
      align
    } = this.config;

    if (this._canPlace(position, align)) {
      this._place(position, align);
    } else {
      this._place(...this._findBestPlace());
    }
  }

}

exports.default = Popover;
