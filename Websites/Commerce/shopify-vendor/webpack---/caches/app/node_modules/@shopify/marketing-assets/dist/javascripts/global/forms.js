'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const formSelector = '.marketing-form';
const floatingSelector = '.marketing-input--floating';
const inputWrapperSelector = '.marketing-input-wrapper';

function toggleFloatingLabels(element, removeFilledClass = false) {
  const $inputWrapper = element.closest(inputWrapperSelector);

  if (!$inputWrapper) {
    return;
  }

  if (element.value.length > 0 && !removeFilledClass) {
    $inputWrapper.classList.add('js-is-filled');
  } else {
    $inputWrapper.classList.remove('js-is-filled');
  }
}

function attachFormsEventListeners() {
  ['change', 'keyup', 'blur'].forEach(eventName => {
    document.body.addEventListener(eventName, evt => {
      if (!(evt.target instanceof Element)) {
        return;
      }

      const input = evt.target.closest(floatingSelector);

      if (input) {
        toggleFloatingLabels(input);
      }
    });
  }); // if the page loads with pre-filled inputs the label should be visible

  document.querySelectorAll(floatingSelector).forEach(element => toggleFloatingLabels(element)); // force-reset event is required due to the clearing of the input (when val.length === 0)
  // occuring after the toggleFloatingLabels function has run

  document.querySelectorAll(formSelector).forEach(form => {
    form.addEventListener('reset', evt => {
      evt.currentTarget.querySelectorAll(floatingSelector).forEach(input => toggleFloatingLabels(input, true));
    });
  });
} // This exists to preserve existing (bad) behaviour that this will happen immediately when
// Marketing Assets is imported from. In other words, applications rely on this side-effect.

attachFormsEventListeners();

exports.attachFormsEventListeners = attachFormsEventListeners;
exports.default = toggleFloatingLabels;
