'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var ScrollTo = require('../global/scroll-to');
var utils = require('../helpers/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var ScrollTo__default = /*#__PURE__*/_interopDefaultLegacy(ScrollTo);

/**
 * Fixed to top navigation.
 *
 * @param {object} [options] optional configuration object
 * @param {$DOM element} [options.$container=$('.sticky-menu-container')] container of sticky nav (one level up).
 * @param {string} [options.classFixed='js-is-sticky-container'] class name added to $container once it meets page top or page top chrome (when you want it to start "sticking").
 * @param {string} [options.classAbs='js-is-abs-container']  class name added to $container once user has scrolled to bottom of page (when you want it to stop "sticking")
 * @param {string} [options.classLinkActive='js-is-active']  class name added to active links in nav
 * @param {number} [options.pageTopMargin=0]  offset in pixels between top of nav item and top of page
 * @param {number} [options.scrollOffset=0]  offset in pixels for the scrollTo position of each link
 * @class StickyNav
 * @namespace ShopifyMarketing
 * @constructor
*/

function StickyNav(options) {
  const config = {
    $container: document.querySelector('.sticky-menu-container'),
    classFixed: 'js-is-sticky-container',
    classAbs: 'js-is-abs-container',
    classLinkActive: 'js-is-active',
    pageTopMargin: 0,
    scrollOffset: 0
  };
  this.options = _objectSpread__default(_objectSpread__default({}, config), options); // Support passing a DOM node as 'container'

  if (this.options.container) {
    this.options.$container = this.options.container;
  }

  if (!this.options.$container) {
    return false;
  }

  this.init();
}

StickyNav.prototype.init = function () {
  const menuContainer = this.options.$container;
  this.menuDom = {
    $menu: menuContainer.querySelector('.sticky-menu'),
    $links: menuContainer.querySelectorAll('.sticky-menu-link'),
    waypoints: menuContainer.querySelectorAll('.js-waypoint')
  };

  if (Object.keys(this.menuDom).every(key => this.menuDom[key].length || this.menuDom[key] !== null)) {
    this.getScrollLimits();
    this.scrollTo = new ScrollTo__default({
      offset: this.options.scrollOffset,
      elements: this.menuDom.$links
    }, link => {
      this.updateActiveLink(link);
    });

    if (this._isMenuFits()) {
      this.options.$container.classList.add('js-is-sticky-init');
      this.bindSticky();
      this.bindWaypoints();
    }
  }
};
/**
 * add active class name to active link
 * add aria-current="true" to active link
 * @method updateActiveLink
 * @param {HTMLElement} el currently active link
*/


StickyNav.prototype.updateActiveLink = function (el) {
  this.menuDom.$links.forEach(linkEl => {
    linkEl.classList.remove(this.options.classLinkActive);
    linkEl.removeAttribute('aria-current');
  });
  el.classList.add(this.options.classLinkActive);
  el.setAttribute('aria-current', true);
};
/**
 * Get values for scrollLimits object (page dimensions and layout)
 * @method  getScrollLimits
 * @return {object}
*/


StickyNav.prototype.getScrollLimits = function () {
  if (document.body.classList.contains('js-modal-open')) {
    return {};
  }

  const containerTop = this.options.$container.getBoundingClientRect().top + window.scrollY;
  this.scrollLimits = {
    containerHeight: Math.round(this.options.$container.offsetHeight),
    menuTop: containerTop - this.options.pageTopMargin,
    menuHeight: Math.round(this.menuDom.$menu.offsetHeight),
    viewHeight: window.innerHeight || document.documentElement.clientHeight
  };
  return this.scrollLimits;
};

StickyNav.prototype._isMenuFits = function () {
  const limits = this.scrollLimits;
  return limits.menuHeight <= limits.viewHeight;
};

StickyNav.prototype._getPageOffsetTop = function () {
  return this.scrollLimits.menuTop;
};

StickyNav.prototype._getPageOffsetBottom = function () {
  return this.scrollLimits.containerHeight + this.scrollLimits.menuTop - this.scrollLimits.menuHeight;
};

StickyNav.prototype.updateStickyNav = function () {
  const $menuContainer = this.options.$container;
  const classFixed = this.options.classFixed;
  const classAbs = this.options.classAbs;
  const scrollTop = window.scrollY;

  if (scrollTop > this._getPageOffsetBottom()) {
    $menuContainer.classList.add(classAbs);
    return;
  }

  if (scrollTop > this._getPageOffsetTop()) {
    $menuContainer.classList.add(classFixed);
    $menuContainer.classList.remove(classAbs);
    return;
  }

  $menuContainer.classList.remove(classAbs, classFixed);
};

StickyNav.prototype.bindSticky = function () {
  const throttledUpdateNav = utils.throttle(() => {
    this.getScrollLimits();
    this.updateStickyNav();
  }, 100, true);
  window.addEventListener('scroll', () => this.updateStickyNav(this));
  window.addEventListener('resize', () => throttledUpdateNav);
  window.addEventListener('load', () => throttledUpdateNav);
};

StickyNav.prototype.bindWaypoints = function () {
  if (typeof window.IntersectionObserver !== 'function') {
    return;
  }

  const handler = entries => {
    entries.forEach(entry => {
      if (!entry.isIntersecting) {
        return;
      }

      const activeLink = this.options.$container.querySelector(`a[href="#${entry.target.id}"]`);
      this.updateActiveLink(activeLink);
    });
  };

  const observer = new IntersectionObserver(handler, {
    threshold: 0.4
  });
  this.menuDom.waypoints.forEach(waypoint => observer.observe(waypoint));
};

exports.default = StickyNav;
