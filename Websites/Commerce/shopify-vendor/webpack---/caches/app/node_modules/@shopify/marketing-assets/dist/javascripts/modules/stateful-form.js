'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var Twine = require('twine');
var utils = require('../helpers/utils');
var keyCodes = require('../global/keycodes');
var FormsAPI = require('./forms-api');
require('./stateful-field');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var Twine__default = /*#__PURE__*/_interopDefaultLegacy(Twine);
var keyCodes__default = /*#__PURE__*/_interopDefaultLegacy(keyCodes);
var FormsAPI__default = /*#__PURE__*/_interopDefaultLegacy(FormsAPI);

function validKeyCode(keyCode) {
  if (keyCode === keyCodes__default.ENTER || keyCode === keyCodes__default.ESC || keyCode === keyCodes__default.TAB || keyCode === keyCodes__default.CAPS_LOCK || keyCode === keyCodes__default.OPTION || keyCode === keyCodes__default.LEFT || keyCode === keyCodes__default.RIGHT || keyCode === keyCodes__default.SHIFT) {
    return false;
  } else {
    return true;
  }
}

const MIN_FIELD_LENGTH = 4;

function StatefulForm(el, i18nNamespace) {
  this.$form = el.querySelector('.stateful-form');
  this.fields = {};
  this.i18nNamespace = i18nNamespace || 'forms';
  this.debouncedValidate = utils.debounce(this.validateField.bind(this), 300);
  this.debouncedHintCheck = utils.debounce(this.hintCheckField.bind(this), 500);
  this.validationFns = {
    // eslint-disable-next-line require-await
    email(value) {
      return _asyncToGenerator__default(function* () {
        return FormsAPI__default.validateEmail(value);
      })();
    },

    // eslint-disable-next-line require-await
    password(value) {
      return _asyncToGenerator__default(function* () {
        return FormsAPI__default.validatePassword(value);
      })();
    }

  };
}

StatefulForm.prototype.eachField = function (fn) {
  Object.keys(this.fields).forEach(field => {
    fn.call(this, this.fields[field]);
  });
};

StatefulForm.prototype.handleFieldKeyup = function (evt, field) {
  if (!validKeyCode(evt.keyCode)) {
    return;
  }

  if (field.config.showHint) {
    this.debouncedHintCheck(field);
  }

  if (field.config.validate && field.config.live) {
    if (field.state.value.length >= MIN_FIELD_LENGTH) {
      field.setState({
        pending: true
      });
      this.debouncedValidate(field);
    } else if (field.state.error || field.state.success) {
      this.debouncedValidate(field);
    }
  }
};

StatefulForm.prototype.handleFieldBlur = function (field) {
  field.handleBlur();

  if (field.config.required) {
    if (field.config.validate) {
      this.validateFieldIfSet(field);
    } else if (field.state.error) {
      field.setState({
        error: !field.state.filled
      });
    }
  }
};

StatefulForm.prototype.handleSubmit = /*#__PURE__*/_asyncToGenerator__default(function* () {
  try {
    yield this.validate();
    yield this.preSubmitHook.bind(this)();
    Twine__default.unbind(this.$form);
    this.$form.submit();
  } catch (error) {
    this.eachField(this.fieldErrorHook);
    this.focusOnError();
  }
});

StatefulForm.prototype.validateFieldIfSet = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default(function* (field) {
    if (field.state.value) {
      try {
        yield this.validateField(field);
      } finally {
        if (field.config.showHint) {
          this.hintCheckField(field);
        }
      }
    }

    return Promise.resolve();
  });

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

StatefulForm.prototype.validateField = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator__default(function* (field) {
    const result = yield this.getValidationFn(field.name).bind(this, field.state.value)();
    const hasError = Object.keys(result).length !== 0;
    field.setState({
      error: hasError,
      success: field.config.showSuccess && !hasError,
      errors: result,
      pending: false
    });

    if (hasError) {
      this.fieldErrorHook(field);
    }
  });

  return function (_x2) {
    return _ref3.apply(this, arguments);
  };
}();

StatefulForm.prototype.hintCheckField = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator__default(function* (field) {
    try {
      const result = yield FormsAPI__default.checkEmailTypo(field.state.value);
      field.setState({
        hint: true,
        suggestion: result.suggestion
      }, true); // The state change above adds html with a Twine click binding
      // Twine needs to bind that node specifically for the suggestion button
      // click binding to work.

      Twine__default.bind(field.node.querySelector('.suggest button'));
    } catch (error) {
      field.setState({
        hint: false
      });
    }
  });

  return function (_x3) {
    return _ref4.apply(this, arguments);
  };
}();

StatefulForm.prototype.validate = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator__default(function* (fields = this.fields) {
    // Set the state of all fields
    Object.keys(fields).forEach(field => fields[field].validateSet()); // Actually do validation of the fields

    const promises = Object.keys(fields).filter(field => fields[field].config.validate).map(field => this.validateFieldIfSet(fields[field])); // For the most part, all these promises will _resolve_. Even
    // if a field does not validate, the state of the field will
    // be changed, but it's up to this to actually fail validation

    yield Promise.all(promises);

    if (this.firstError(fields)) {
      return Promise.reject(new Error('The form did not validate'));
    }

    return Promise.resolve();
  });

  return function () {
    return _ref5.apply(this, arguments);
  };
}();

StatefulForm.prototype.firstError = function (flds) {
  const fields = flds || this.fields;
  const fieldKeys = Object.keys(fields);
  let firstError;

  for (let i = 0; i < fieldKeys.length; i++) {
    const field = fieldKeys[i];

    if (fields[field].state.error) {
      firstError = fields[field];
      break;
    }
  }

  return firstError;
};

StatefulForm.prototype.focusOnError = function () {
  const field = this.firstError();
  field.handleFocus();
  field.node.querySelector('input').focus();
};

StatefulForm.prototype.focusOnField = function (fld) {
  const field = this.fields[fld];
  field.handleFocus();
  field.node.querySelector('input').focus();
}; // to be optionally overridden by child class


StatefulForm.prototype.preSubmitHook = function () {
  return Promise.resolve();
}; // to be overridden by child class


StatefulForm.prototype.fieldErrorHook = function () {
  return true;
}; // should return a function that returns a deferred


StatefulForm.prototype.getValidationFn = function (field) {
  return this.validationFns[field];
};

Twine__default.register('StatefulForm', StatefulForm);

exports.default = StatefulForm;
