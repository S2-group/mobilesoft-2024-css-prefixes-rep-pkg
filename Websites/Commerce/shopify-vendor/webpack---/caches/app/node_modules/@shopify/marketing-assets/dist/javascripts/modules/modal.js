'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var keyCodes = require('../global/keycodes');
var I18n = require('../global/i18n');
var A11y = require('../global/a11y-helpers');
var EventEmitter = require('../helpers/event-emitter');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var keyCodes__default = /*#__PURE__*/_interopDefaultLegacy(keyCodes);
var I18n__default = /*#__PURE__*/_interopDefaultLegacy(I18n);
var A11y__default = /*#__PURE__*/_interopDefaultLegacy(A11y);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

function anonymous(locals, escapeFn, include, rethrow
) {
rethrow = rethrow || function rethrow(err, str, flnm, lineno, esc){
  var lines = str.split('\n');
  var start = Math.max(lineno - 3, 0);
  var end = Math.min(lines.length, lineno + 3);
  var filename = esc(flnm); // eslint-disable-line
  // Error context
  var context = lines.slice(start, end).map(function (line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
};
escapeFn = escapeFn || function (markup) {
  return markup == undefined
    ? ''
    : String(markup)
      .replace(_MATCH_HTML, encode_char);
};
var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
}var __line = 1
  , __lines = "<div class=\"modal-container\" id=\"ModalContainer\" aria-hidden=\"true\">\n  <div class=\"modal\" role=\"dialog\" tabindex=\"-1\" aria-labelledby=\"ModalTitle\" aria-modal=\"true\">\n    <div class=\"modal__header\">\n      <div class=\"modal__controls\">\n        <button type=\"button\" class=\"modal__close\" id=\"CloseModal\">\n          <span class=\"icon\" id=\"CloseIcon\">\n            <span class=\"visuallyhidden\"><%= locals.closeLabel %></span>\n          </span>\n        </button>\n      </div>\n    </div>\n    <div class=\"modal__content\"></div>\n  </div>\n</div>\n"
  , __filename = undefined;
try {
  var __output = "";
  function __append(s) { if (s !== undefined && s !== null) __output += s; }
    ; __append("<div class=\"modal-container\" id=\"ModalContainer\" aria-hidden=\"true\">\n  <div class=\"modal\" role=\"dialog\" tabindex=\"-1\" aria-labelledby=\"ModalTitle\" aria-modal=\"true\">\n    <div class=\"modal__header\">\n      <div class=\"modal__controls\">\n        <button type=\"button\" class=\"modal__close\" id=\"CloseModal\">\n          <span class=\"icon\" id=\"CloseIcon\">\n            <span class=\"visuallyhidden\">")
    ; __line = 7
    ; __append(escapeFn( locals.closeLabel ))
    ; __append("</span>\n          </span>\n        </button>\n      </div>\n    </div>\n    <div class=\"modal__content\"></div>\n  </div>\n</div>\n")
    ; __line = 15;
  return __output;
} catch (e) {
  rethrow(e, __lines, __filename, __line, escapeFn);
}

}

/**
 * Modal window
 * @param {HTMLElement|NodeList}  elements Element(s) triggering the modal, usually a button or anchor
 * @param {function}              template compiled ejs template for modal
 * @param {object}                [options] optional configuration object
 * @param {string}                [options.modalActiveBodyClass='js-modal-open'] class added to body while modal is open
 * @param {string}                [options.modalActiveContainerClass='js-is-active'] class added to modal container element while modal is open
 * @param {object}                [options.modalStyleModifierClasses={container: 'modal-container--lowlight', closeIcon: 'icon-modules-close-white'}] optional style modifer classes for container and close icon
 * @param {boolean}               [options.clickingOverlayClosesModal=true] whether clicking background of modal closes modal
 * @param {boolean}               [options.emptyOnClose=true] whether modal DOM is emptied when modal closed.
 * @param {boolean}               [options.preventEventDefault=true] whether to call preventDefault on the clicking event of the modal trigger
 * @param {function}              [options.afterModalRender=null] callback function after modal template is rendered, receives the modal element
 * @param {number}                [options.transitionLength=200] Time in ms to wait for the modal to close and fire transitionEnd before performing fallback cleanup
 * @class Modal
 * @namespace ShopifyMarketing
 * @constructor
*/

function Modal(elements, template, options) {
  var _this$$modalSources$s;

  EventEmitter__default.apply(this);
  const defaults = {
    modalActiveBodyClass: 'js-modal-open',
    modalActiveContainerClass: 'js-is-active',
    modalStyleModifierClasses: {
      container: 'modal-container--lowlight',
      closeIcon: 'icon-modules-close-white'
    },
    clickingOverlayClosesModal: true,
    emptyOnClose: true,
    preventEventDefault: true,
    afterModalRender: null,
    transitionLength: 200
  };
  this.options = _objectSpread__default(_objectSpread__default({}, defaults), options);

  if (!document.getElementById('ModalContainer')) {
    const container = document.createElement('div');
    container.innerHTML = anonymous({
      closeLabel: I18n__default.t('modal.close')
    });
    document.body.insertBefore(container.firstChild, document.body.childNodes[0]);
  }

  this.modalDom = {
    $container: document.getElementById('ModalContainer'),
    $modal: document.querySelector('.modal__content'),
    $modalControls: document.querySelector('.modal__controls'),
    $closeBtn: document.getElementById('CloseModal'),
    $closeIcon: document.getElementById('CloseIcon')
  };
  this.modalTransitioningContainerClass = 'js-is-transitioning'; // Whatever was passed in, convert to an array of HTMLElements

  if (elements.length) {
    this.$modalSources = [...elements];
  } else if (elements && elements.length !== 0) {
    // This case excludes empty NodeLists
    this.$modalSources = [elements];
  } else {
    this.$modalSources = [];
  }

  this._onClick = this._onClick.bind(this);
  this._onBackdropClick = this._onBackdropClick.bind(this);
  this._onKeyDown = this._onKeyDown.bind(this);
  this.close = this.close.bind(this);
  this.onCloseButtonClick = this.onCloseButtonClick.bind(this);
  this.$modalSources.forEach(el => el.addEventListener('click', this._onClick));
  this.$modalSources.forEach(el => el.addEventListener('keydown', this._onKeyDown));
  this.modalDom.$closeBtn.addEventListener('click', this.onCloseButtonClick);
  this.template = template; // Create a fallback dataset to pass to the template from the first element to support legacy behaviour

  this.fallbackDataset = _objectSpread__default({}, (_this$$modalSources$s = this.$modalSources.slice().pop()) === null || _this$$modalSources$s === void 0 ? void 0 : _this$$modalSources$s.dataset);
  this.active = false;
}

Modal.prototype = Object.create(EventEmitter__default.prototype);
/**
 * Open modal window
 * @method  open
 * @param {Event} evt event object returned from click event handler
*/

Modal.prototype.open = function (evt) {
  this.scrollTopPosition = this.getScroll();

  if (evt) {
    this.$modalTrigger = evt.currentTarget;
  }

  this.render();
  const container = this.modalDom.$container;

  if (this.options.clickingOverlayClosesModal) {
    container.addEventListener('click', this._onBackdropClick);
  }

  container.addEventListener('keydown', this._onKeyDown);
  this.addClasses(this.modalDom.$closeIcon, this.options.modalStyleModifierClasses.closeIcon);
  this.addClasses(container, this.options.modalStyleModifierClasses.container);
  this.toggleState();
  this.addClasses(container, this.options.modalActiveContainerClass);
  this.addClasses(document.body, this.options.modalActiveBodyClass);
  container.scrollTop = 0;
  A11y__default.prototype.trapFocus(container);
  this.modalDom.$container.focus();
  this.emit('opened', evt);
};
/**
 * Removes a list of space-separated classes from the provided element
 * @method removeClasses
 * @param {HTMLElement} el the element which the classes should be removed from
 * @param {String} classListString a string of class names (space separated) to remove from the element (eg 'js-modal-open modal--custom')
*/


Modal.prototype.removeClasses = function (el, classListString) {
  if (el && classListString) {
    classListString.split(' ').forEach(className => {
      el.classList.remove(className);
    });
  }
};
/**
 * Adds a list of space-separated classes to the provided element
 * @method  removeClasses
 * @param {HTMLElement} el the element which the classes should be added to
 * @param {String} classListString a string of class names (space separated) to add to the element (eg 'js-modal-open modal--custom')
*/


Modal.prototype.addClasses = function (el, classListString) {
  if (el && classListString) {
    classListString.split(' ').forEach(className => {
      el.classList.add(className);
    });
  }
};
/**
* Close modal window
* @method close
* @param {function} [callback] function called after modal is closed
*/


Modal.prototype.close = function (callback) {
  const onClosed = () => {
    if (this.options.emptyOnClose) {
      this.empty();
    }

    if (typeof callback === 'function') {
      callback();
    }

    this.emit('closed');
  };

  const container = this.modalDom.$container;
  container.removeEventListener('click', this._onBackdropClick);
  container.removeEventListener('keydown', this._onKeyDown);
  this.toggleState(onClosed);
  this.removeClasses(this.modalDom.$container, this.options.modalActiveContainerClass);
  this.removeClasses(document.body, this.options.modalActiveBodyClass); // Remove modifier classes from icon and container

  this.removeClasses(this.modalDom.$closeIcon, this.options.modalStyleModifierClasses.closeIcon);
  this.removeClasses(this.modalDom.$container, this.options.modalStyleModifierClasses.container); // turn off the focus listener

  A11y__default.prototype.removeTrapFocus(this.modalDom.$container);

  if (this.$modalTrigger) {
    this.$modalTrigger.focus();
  } else if (this.$modalSources.length) {
    this.$modalSources[0].focus();
  }

  this.setScroll(this.scrollTopPosition);
};
/**
 * Toggles the modal. Handles making the modal visible, setting aria-attributes.
 * and setting up a callback for when transition is complete, including a fallback using timeout.
 * @method toggleState
 * @param {Function} callback callback to run after the transition completes
*/


Modal.prototype.toggleState = function (callback) {
  this.active = !this.active;
  this.modalDom.$container.classList.add(this.modalTransitioningContainerClass);
  /* eslint-disable babel/no-unused-expressions */
  // Force a redraw on the drawer otherwise the transition is not visible

  this.modalDom.$container.offsetHeight;
  /* eslint-enable babel/no-unused-expressions */

  this.modalDom.$container.setAttribute('aria-hidden', !this.active);
  this.transitionEndCallback = this._onTransitionEnd.bind(this, callback);
  this.pendingTransitionFallback = setTimeout(this.transitionEndCallback, this.options.transitionLength);
  this.modalDom.$container.addEventListener('transitionend', this.transitionEndCallback);
};
/**
 * Runs after transition has finished on modal container, cleans up transitioning classes and calls callback
 * Expects a fallback method to have been created
 * @private
 * @method  _onTransitionEnd
 * @param {Function} callback callback to run after the transition completes
*/


Modal.prototype._onTransitionEnd = function (callback) {
  if (!this.pendingTransitionFallback) {
    return;
  } // Reset the fallback and remove event listener


  clearTimeout(this.pendingTransitionFallback);
  this.pendingTransitionFallback = null;
  this.modalDom.$container.removeEventListener('transitionend', this.transitionEndCallback); // Remove transitioning class

  this.modalDom.$container.classList.remove(this.modalTransitioningContainerClass);

  if (typeof callback === 'function') {
    callback();
  }
};
/**
 * Return the current scroll position from the top in pixels.
 *
 * @method getScroll
 * @return {integer}
 */


Modal.prototype.getScroll = function () {
  return window.scrollY;
};
/**
 * Set the current scroll top position to the given value
 *
 * @method setScroll
 * @param {integer} value  In pixels
 */


Modal.prototype.setScroll = function (value) {
  window.scrollTo({
    top: value
  });
};
/**
 * Removes the contents of the modal from the DOM.
 *
 * @method empty
 */


Modal.prototype.empty = function () {
  this.modalDom.$modal.innerHTML = '';
};
/**
 * Renders the modal content, invoking the template with the data attributes
 * from the modal trigger element.
 *
 * Optionally invoke `afterModalRender` function if it was passed.
 *
 * @method render
 */


Modal.prototype.render = function () {
  const modalMarkup = this.template(this.getTemplateData());

  if (typeof modalMarkup === 'string') {
    this.modalDom.$modal.innerHTML = modalMarkup;
  } else {
    this.modalDom.$modal.innerHTML = '';
    this.modalDom.$modal.appendChild(modalMarkup);
  }

  if (this.options.afterModalRender) {
    this.options.afterModalRender(this.modalDom.$modal);
  }
};
/**
 * Get the data to populate the modal template from data attributes on the event trigger
 *
 * @method getTemplateData
 */


Modal.prototype.getTemplateData = function () {
  if (this.$modalTrigger) {
    return _objectSpread__default(_objectSpread__default({}, this.fallbackDataset), this.$modalTrigger.dataset);
  }

  return this.fallbackDataset;
};

Modal.prototype._onClick = function (evt) {
  if (this.options.preventEventDefault) {
    evt.preventDefault();
  }

  this.open(evt);
};

Modal.prototype._onKeyDown = function (evt) {
  if (this.active) {
    switch (evt.keyCode) {
      case keyCodes__default.ESCAPE:
        this.close();
        break;
    }
  }
};

Modal.prototype._onBackdropClick = function (evt) {
  if (evt.target === evt.currentTarget && this.active) {
    this.close();
  }
};

Modal.prototype.onCloseButtonClick = function () {
  if (this.active) {
    this.close();
  }
};

exports.default = Modal;
