'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var utils = require('../helpers/utils');
var A11y = require('./a11y-helpers');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var A11y__default = /*#__PURE__*/_interopDefaultLegacy(A11y);

const ease = x => 0.5 * (1 - Math.cos(Math.PI * x));
/**
 * This class provides the means to smoothly scroll to targets on the same page.
 * While `scroll-behaviour: smooth` and `scroll-snap-margin` exist, they aren't
 * supported in Safari (as of March 2021), the scroll duration cannot be changed
 * and we don't get a callback to know when scrolling is "done". This is required
 * so we are able to make the scroll accessible (including not transitioning
 * when the user has `prefersReducedMotion` enabled.)
 *
 * @see https://css-tricks.com/smooth-scrolling-accessibility/
 */


class ScrollTo {
  /**
   * @class ScrollTo
   * @constructor
   * @param {Object} [options] configuration options
   * @param {String} [options.elements=NodeList['.link-scroll-to']]
   *   A NodeList of links that we want smooth scroll behaviour for.
   * @param {Integer} [options.offset=0]
   *   A fixed offset to add when determining how far the window should scroll. Useful for
   *   handling sticky elements.
   * @param {Integer} [options.scrollTime=500]
   *   How long the animation should last for
   * @param {Function} [callback] Callback to fire when the scroll transition has completed.
   */
  constructor(options, callback) {
    const config = {
      elements: document.querySelectorAll('.link-scroll-to'),
      offset: 0,
      scrollTime: 500
    };
    this.options = _objectSpread__default(_objectSpread__default({}, config), options);

    if (utils.prefersReducedMotion()) {
      this.options.scrollTime = 0;
    }

    this.callback = callback;
    this.init();
  }

  init() {
    Array.from(this.options.elements).forEach(element => element.addEventListener('click', evt => this.handleClick(evt)));
  }

  handleClick(evt) {
    const link = evt.currentTarget;

    if (!utils.isLinkToCurrentPage(link)) {
      return;
    }

    evt.preventDefault();
    this.updateUrlWithHash(link.hash);

    if (link.hash && link.hash.toLowerCase() !== '#top') {
      this.scrollToTarget(link);
    } else {
      this.scrollToTop(link);
    }
  }

  scrollToTop(link) {
    // eslint-disable-next-line promise/catch-or-return
    this.scroll(0).then(() => this.handleScrollComplete(link, document.getElementById('PageContainer')));
  }

  scrollToTarget(link) {
    const target = document.querySelector(decodeURIComponent(link.hash));

    if (!target) {
      return;
    }

    const offsetTop = target.getBoundingClientRect().top + this.options.offset + window.scrollY; // eslint-disable-next-line promise/catch-or-return

    this.scroll(offsetTop).then(() => this.handleScrollComplete(link, target));
  }

  updateUrlWithHash(hash) {
    window.history.replaceState({}, document.title, hash);
  }

  scroll(desired) {
    return new Promise(resolve => {
      this.scrollStep({
        startTime: performance.now(),
        start: window.scrollY,
        desired
      }, resolve);
    });
  } // eslint-disable-next-line consistent-return


  scrollStep(context, resolve) {
    const time = performance.now();
    const elapsed = Math.min((time - context.startTime) / this.options.scrollTime, 1);
    const easingFactor = ease(elapsed);
    const fromTop = context.start + (context.desired - context.start) * easingFactor;
    window.scrollTo({
      top: fromTop
    });

    if (fromTop === context.desired) {
      return resolve();
    } else {
      window.requestAnimationFrame(() => this.scrollStep(context, resolve));
    }
  }

  handleScrollComplete(link, $target) {
    if ($target && $target.length) {
      A11y__default.prototype.pageLinkFocus($target.get(0));
    }

    if (typeof this.callback === 'function') {
      this.callback(link, $target);
    }
  }

}

exports.default = ScrollTo;
