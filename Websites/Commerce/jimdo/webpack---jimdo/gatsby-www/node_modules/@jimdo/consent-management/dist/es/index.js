import Cookies from 'js-cookie';
import seedrandom from 'seedrandom';
const setLocale = languageCode => localeSetter => {
  localeSetter(languageCode);
};
const Languages = ["de", "en", "nl", "fr", "es", "it", "ja"];
const SpecialGeoLocations = {
  "/jp": "ja",
  "/au": "en",
  "/nl": "nl",
  "/es": "es",
  "/fr": "fr",
  "/it": "it",
  "/de": "de"
};
// german pages aren't prefixed in Unbounce
// reason: Unbounce was started with DE language, making it the default language ("/")
const UnbounceGeoLocations = {
  "/jp/": "ja",
  "/nl/": "nl",
  "/es/": "es",
  "/fr/": "fr",
  "/it/": "it",
  "/en/": "en"
};
const fallBack = "en";
const unbounceFallBack = "de";
function computeLang() {
  try {
    if (typeof window === "undefined") {
      return fallBack;
    }
    const {
      hostname,
      pathname
    } = window.location;
    if (hostname.indexOf("www-") === 0 || hostname === "jimdo.com" || hostname === "www.jimdo.com" || hostname === "localhost") {
      const match = Object.keys(SpecialGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? SpecialGeoLocations[match] : fallBack;
    }
    // Unbounce pages at go.jimdo.com:
    // German pages aren't prefixed in Unbounce, as the tool was started in german.
    // Therefore DE is the default language
    if (hostname === "go.jimdo.com") {
      const match = Object.keys(UnbounceGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? UnbounceGeoLocations[match] : unbounceFallBack;
    }
    if (hostname === "help.jimdo-dolphin.com" || hostname === "help.jimdo.com" || hostname === "jimdo-partner.zendesk.com") {
      return Languages.find(lang => pathname.startsWith(`/hc/${lang}`)) || fallBack;
    }
    if (hostname === "logo.e.jimdo.com") {
      const i18nextLng = Cookies.get("i18nextLng") || fallBack;
      return Languages.find(lang => i18nextLng.startsWith(lang)) || fallBack;
    }
    if (hostname === "account.e.jimdo.com" || hostname === "account.e.jimdo-stable-staging.com") {
      return Languages.find(lang => pathname.startsWith(`/${lang}/`)) || fallBack;
    }
    const jLang = Cookies.get("jLang") || fallBack;
    return Languages.find(lang => jLang.startsWith(lang)) || fallBack;
  } catch (e) {
    //See: https://stackoverflow.com/questions/64452484/how-can-i-safely-access-caught-error-properties-in-typescript
    const {
      message
    } = e;
    // eslint-disable-next-line no-console
    console.log(`Consent Management: Couldn't determine language: ${message}`);
    return fallBack;
  }
}
const listenToConsentChange = (listener, callback) => {
  listener(callback);
};
const userCentricsConsentChangeListener = function () {
  let consentChangeEventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ucChange";
  return callback => {
    window.addEventListener(consentChangeEventName, e => {
      const userCentricsEvent = e;
      const {
        detail
      } = userCentricsEvent;
      if (!detail || !callback) {
        return;
      }
      const {
        event,
        type,
        ...services
      } = detail;
      const filteredServices = Object.keys(services).filter(service => service !== "action");
      const dps = filteredServices.map(dpsName => ({
        dpsName,
        consent: services[dpsName]
      }));
      callback(dps);
    });
  };
};
const onConsentChange = callback => {
  const dpsConsent = {};
  return dpsConsentChanges => {
    const userInteraction = Object.keys(dpsConsent).length > 0;
    for (const {
      dpsName,
      consent
    } of dpsConsentChanges) {
      if (dpsConsent[dpsName] === consent) {
        continue;
      }
      dpsConsent[dpsName] = consent;
      callback(dpsName, consent, userInteraction);
    }
  };
};
const configureScriptAttribute = (attributeName, attributeValue) => scriptElement => {
  scriptElement.setAttribute(attributeName, attributeValue);
  return scriptElement;
};
const createScriptWithSrc = src => {
  return () => {
    const script = document.createElement("script");
    script.src = src;
    return script;
  };
};
const createScriptWithContent = scriptContent => {
  return () => {
    const script = document.createElement("script");
    script.appendChild(document.createTextNode(scriptContent));
    return script;
  };
};
const documentHeadLoader = script => {
  return document.head.appendChild(script);
};
const documentBodyLoader = script => {
  return document.body.appendChild(script);
};
const loadScript = function (creator) {
  let {
    loader = documentBodyLoader,
    configurators
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const script = creator();
  const configuredScript = configurators ? configurators.reduce((scriptElement, configurator) => configurator(scriptElement), script) : script;
  loader(configuredScript);
};
const CROSS_DOMAIN_CONSENT_SHARING_IFRAME_URL = "https://www.jimdo.com/consent-management/cross-domain-bridge.html";
const loadUserCentrics = (settingsId, suppressConsentBanner, draftVersion, onLoad) => {
  window.addEventListener("UC_UI_INITIALIZED", onLoad);
  if (suppressConsentBanner) {
    loadScript(createScriptWithContent(`var UC_UI_SUPPRESS_CMP_DISPLAY=true;`), {
      loader: documentHeadLoader
    });
  }
  loadScript(createScriptWithContent(`window.UC_UI_DOMAINS = {
      crossDomainConsentSharingIFrame: '${CROSS_DOMAIN_CONSENT_SHARING_IFRAME_URL}',
    };`), {
    loader: documentHeadLoader
  });
  if (draftVersion) {
    return loadScript(createScriptWithSrc(`https://app.usercentrics.eu/browser-ui/latest/loader.js`), {
      loader: documentHeadLoader,
      configurators: [configureScriptAttribute("id", "usercentrics-cmp"), configureScriptAttribute("data-settings-id", settingsId), configureScriptAttribute("data-version", "preview")]
    });
  }
  !draftVersion && loadScript(createScriptWithSrc(`https://app.usercentrics.eu/browser-ui/latest/loader.js`), {
    loader: documentHeadLoader,
    configurators: [configureScriptAttribute("id", "usercentrics-cmp"), configureScriptAttribute("data-settings-id", settingsId)]
  });
};
const getDpsConsent = dps => dpsName => {
  const service = dps.find(s => s.name === dpsName);
  if (!service) {
    return false;
  }
  return service.consent;
};
const getUserCentrics = () => {
  const INTERVAL_TIME = 500;
  const TIMEOUT_TIME = 5000;
  let interval;
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(`getUserCentrics timed out`), TIMEOUT_TIME);
  });
  const waitingForUserCentricsPromise = new Promise(resolve => {
    const checkUserCentrics = () => {
      if (window.UC_UI) {
        resolve(window.UC_UI);
        if (typeof interval !== "undefined") {
          clearInterval(interval);
        }
        return;
      }
      if (typeof interval === "undefined") {
        interval = setInterval(checkUserCentrics, INTERVAL_TIME);
      }
    };
    checkUserCentrics();
  });
  return Promise.race([timeoutPromise, waitingForUserCentricsPromise]).catch(e => {
    if (typeof interval !== "undefined") {
      clearInterval(interval);
    }
    throw e;
  });
};
const isConsentManagementLoaded = () => getUserCentrics().then(() => true);
const acceptAllConsents = () => getUserCentrics().then(UC_UI => UC_UI.acceptAllConsents());
const denyAllConsents = () => getUserCentrics().then(UC_UI => UC_UI.denyAllConsents());
const showConsentBanner = function () {
  let {
    layer
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    layer: 1
  };
  return getUserCentrics().then(UC_UI => layer === 1 ? UC_UI.showFirstLayer() : UC_UI.showSecondLayer());
};
const closeConsentBanner = () => getUserCentrics().then(UC_UI => UC_UI.closeCMP());
const setConsentBannerLanguage = language => getUserCentrics().then(UC_UI => UC_UI.updateLanguage(language));
const updateConsentStatus = getConsentStatus => (dpsName, consent, userInteraction) => {
  const consentStatus = getConsentStatus();
  if (!consentStatus) {
    return;
  }
  consentStatus[dpsName] = {
    consent,
    userInteraction
  };
};
const dispatchConsentChangedGlobalEvent = eventName => (dpsName, consent, userInteraction) => {
  if (typeof window === "undefined") {
    return;
  }
  const event = new CustomEvent(eventName, {
    detail: {
      dpsName,
      consent,
      userInteraction
    }
  });
  window.dispatchEvent(event);
};
const userCentricsBannerInteractionListener = callback => {
  window.addEventListener("UC_UI_CMP_EVENT", e => {
    const userCentricsEvent = e;
    const {
      detail
    } = userCentricsEvent;
    if (!detail || !callback) {
      return;
    }
    const {
      source,
      type
    } = detail;
    callback(source, type);
  });
};
const mapLayerToSource = source => {
  switch (source) {
    case "FIRST_LAYER":
      return 1;
    case "SECOND_LAYER":
      return 2;
    default:
      return 1;
  }
};
const dispatchConsentBannerInteractionGlobalEvent = eventName => (source, type) => {
  if (typeof window === "undefined") {
    return;
  }
  const event = new CustomEvent(eventName, {
    detail: {
      type,
      layer: mapLayerToSource(source)
    }
  });
  window.dispatchEvent(event);
};
const getDps = (fetcher, transformer) => {
  const dps = fetcher();
  return transformer(dps);
};
const getUserCentricsDps = () => window.UC_UI.getServicesBaseInfo();
const userCentricsDpsTransformer = userCentricsDps => {
  return userCentricsDps.map(dps => {
    var _dps$deviceStorage;
    return {
      name: dps.name,
      category: dps.categorySlug,
      consent: dps.consent.status,
      deviceStorage: ((_dps$deviceStorage = dps.deviceStorage) === null || _dps$deviceStorage === void 0 ? void 0 : _dps$deviceStorage.disclosures) || []
    };
  });
};
const getDpsCookieNames$1 = dps => dpsName => {
  const service = dps.find(s => s.name === dpsName);
  if (!service) {
    return [];
  }
  return service.deviceStorage.filter(storage => storage.type === "cookie").map(storage => storage.name);
};
const JIMDO_CONSENT_CHANGED_EVENT_NAME = "JIMDO_CONSENT_CHANGED";
const JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME = "JIMDO_CONSENT_BANNER_INTERACTION";
const seed = _ref => {
  let {
    testName,
    cookieName = "shd"
  } = _ref;
  const cookieValue = Cookies.get(cookieName);
  if (!cookieValue) {
    // This especially happens for browsers without support for cookies.
    // For example: google bot in headless mode.
    // We remove all of these browsers from testing because we can not reliably
    // put them into the same group at each visit.
    return undefined;
  } else {
    const randomRg = seedrandom(`${testName}${cookieValue}`);
    return randomRg();
  }
};

/**
 *
 * @param configuration.onConsentChange gets called on every state change with the first argument being the service name, the second the consent status and the third whether the change resulted from a user interaction
 * @param configuration.skipCookieBanner skip the cookiebanner and simply accept the set cookies
 * @param configuration.userCentricsSettingsId user centrics settings id
 * @param configuration.forceLanguage overwrite the language
 */
const init = configuration => {
  if (!configuration) {
    console.error(`Consent management init called without configuration`);
    return;
  }
  const {
    forceLanguage,
    skipCookieBanner,
    userCentricsSettingsId,
    suppressConsentBanner = false,
    draftVersion = false
  } = configuration;
  const updateGlobalConsentStatus = updateConsentStatus(() => {
    if (typeof window === "undefined") {
      return;
    }
    if (!window.__jimdo__) {
      return;
    }
    return window.__jimdo__.CONSENT_STATUS;
  });
  const dispatchConsentChangedJimdoEvent = dispatchConsentChangedGlobalEvent(JIMDO_CONSENT_CHANGED_EVENT_NAME);
  const dispatchConsentBannerInteractionJimdoEvent = dispatchConsentBannerInteractionGlobalEvent(JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME);
  userCentricsBannerInteractionListener(dispatchConsentBannerInteractionJimdoEvent);
  const callback = (dpsName, consent, userInteraction) => {
    if (configuration.onConsentChange) {
      console.warn("onConsentChange is deprecated");
      configuration.onConsentChange(dpsName, consent, userInteraction);
    }
    updateGlobalConsentStatus(dpsName, consent, userInteraction);
    dispatchConsentChangedJimdoEvent(dpsName, consent, userInteraction);
  };
  try {
    if (userCentricsSettingsId && !skipCookieBanner) {
      loadUserCentrics(userCentricsSettingsId, suppressConsentBanner, draftVersion, () => {
        const language = forceLanguage || computeLang();
        setLocale(language)(setConsentBannerLanguage);
      });
      listenToConsentChange(userCentricsConsentChangeListener(), onConsentChange(callback));
    }
  } catch (e) {
    /* eslint-disable no-console */
    console.error(`Consent management throws an error.`);
    console.error(e);
  }
};
const getDpsCookieNames = dpsName => getDpsCookieNames$1(getDps(getUserCentricsDps, userCentricsDpsTransformer))(dpsName);
const isOptedIn = dpsName => getDpsConsent(getDps(getUserCentricsDps, userCentricsDpsTransformer))(dpsName);
const addApiToWindow = () => {
  if (typeof window === "undefined") {
    return;
  }
  window.__jimdo__ = {
    ...(window.__jimdo__ || {}),
    initConsent: init,
    getDpsCookieNames,
    seed,
    isConsentManagementLoaded,
    acceptAllConsents,
    denyAllConsents,
    showConsentBanner,
    closeConsentBanner,
    setConsentBannerLanguage,
    CONSENT_STATUS: {}
  };
};
addApiToWindow();
export { acceptAllConsents, closeConsentBanner, denyAllConsents, getDpsCookieNames, init, isConsentManagementLoaded, isOptedIn, setConsentBannerLanguage, showConsentBanner };