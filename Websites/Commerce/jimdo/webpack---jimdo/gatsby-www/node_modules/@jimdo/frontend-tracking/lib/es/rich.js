import * as FullStory from '@fullstory/browser';
import { generateSid, getTopic, getShortTopic, getLanguage, STAGING_HOSTS } from './common.js';
import { sendEvent } from './sendEvent.js';
import omit from 'just-omit';
let hasFullstoryEnabled = false;
const fsTrackingBlacklist = ['cms.text.edit', 'cms.website.save'];
const fsTrackingPropertyBlacklist = ['auto', 'viewportHeight', 'viewportWidth', 'geo', 'userId', 'uiUserId', 'gtm.start', 'eventLabel', 'eventCategory', 'eventAction', 'event', 'language subdomain'];
const isFsTrackingBlacklistedItem = eventName => fsTrackingBlacklist.includes(eventName);
(() => {
  if (typeof window === 'undefined') {
    return;
  }
  window['_fs_ready'] = function () {
    hasFullstoryEnabled = true;
  };
})();
let fullStoryTracker = null;
const makeFullStoryTracker = (waitForConsent, userAccountId) => {
  let hasFullstoryConsent = false;
  waitForConsent(() => {
    hasFullstoryConsent = true;
    if (!hasFullstoryEnabled) {
      FullStory.init({
        orgId: '5F864'
      }, () => {
        if (userAccountId) {
          FullStory.identify(userAccountId);
        }
      });
      hasFullstoryEnabled = true;
    }
  });
  return (eventName, eventData) => {
    if (!hasFullstoryConsent || !hasFullstoryEnabled) {
      return;
    }
    FullStory.event(eventName, eventData);
  };
};
// these two constants could be delegated to a config file or env vars
const TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/rich';
const TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/rich';
// Monotonically increasing ticker for sent messages. This allows us to detect if messages went missing or arrived out
// of order
let seq = 0;
// A session ID. The purpose of this ID is to uniquely identify a session, within which the `seq` is supposed to be
// monotmonotonically increasing. The session id gets generated on library load, this should mean, there is one session
// id per: browser, tab, refresh
const TRACKING_SID = generateSid();
const RichTracking = config => event => {
  var _config$getSeedPayloa, _config$getUserAgent, _config$getLanguage, _config$getReferrer, _config$getLocation, _config$userAccountId, _config$websiteId;
  const topic = getTopic(event, config.logToConsole || false);
  const shortTopic = getShortTopic(event, config.logToConsole || false);
  const seedPayload = (config === null || config === void 0 ? void 0 : (_config$getSeedPayloa = config.getSeedPayload) === null || _config$getSeedPayloa === void 0 ? void 0 : _config$getSeedPayloa.call(config)) ?? {};
  const message = {
    userAgent: (config === null || config === void 0 ? void 0 : (_config$getUserAgent = config.getUserAgent) === null || _config$getUserAgent === void 0 ? void 0 : _config$getUserAgent.call(config)) ?? navigator.userAgent,
    isAffiliate: config.isAffiliate && config.isAffiliate(),
    language: (config === null || config === void 0 ? void 0 : (_config$getLanguage = config.getLanguage) === null || _config$getLanguage === void 0 ? void 0 : _config$getLanguage.call(config)) ?? getLanguage(),
    referrer: (config === null || config === void 0 ? void 0 : (_config$getReferrer = config.getReferrer) === null || _config$getReferrer === void 0 ? void 0 : _config$getReferrer.call(config)) ?? document.referrer,
    location: (config === null || config === void 0 ? void 0 : (_config$getLocation = config.getLocation) === null || _config$getLocation === void 0 ? void 0 : _config$getLocation.call(config)) ?? document.location.href,
    ...seedPayload,
    ...event.payload
  };
  const data = {
    anonId: config.anonId(),
    env: config.env,
    userAccountId: config === null || config === void 0 ? void 0 : (_config$userAccountId = config.userAccountId) === null || _config$userAccountId === void 0 ? void 0 : _config$userAccountId.call(config),
    websiteId: config === null || config === void 0 ? void 0 : (_config$websiteId = config.websiteId) === null || _config$websiteId === void 0 ? void 0 : _config$websiteId.call(config),
    message: JSON.stringify(message),
    topic,
    seq: seq++,
    sid: TRACKING_SID
  };
  if (config.logToConsole) {
    console.log(`frontend-tracking: event "${data.topic}" tracked`, message, data);
  }
  if (config !== null && config !== void 0 && config.fullStoryConfig && !fullStoryTracker) {
    const {
      waitForConsent
    } = config.fullStoryConfig();
    fullStoryTracker = makeFullStoryTracker(waitForConsent, data.userAccountId);
  }
  if (fullStoryTracker && !isFsTrackingBlacklistedItem(topic)) {
    const payload = event.payload ? omit(event.payload, fsTrackingPropertyBlacklist) : {};
    fullStoryTracker(shortTopic, {
      env: data.env,
      topic,
      ...payload
    });
  }
  const dataJSON = JSON.stringify(data);
  sendEvent(config.endpoint, dataJSON, config === null || config === void 0 ? void 0 : config.sendBeacon);
};
function getRichTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? TRACKING_ENDPOINT_STAGE : TRACKING_ENDPOINT_PROD;
}
export { RichTracking, TRACKING_ENDPOINT_PROD, TRACKING_ENDPOINT_STAGE, TRACKING_SID, getRichTrackingEndpoint, makeFullStoryTracker };