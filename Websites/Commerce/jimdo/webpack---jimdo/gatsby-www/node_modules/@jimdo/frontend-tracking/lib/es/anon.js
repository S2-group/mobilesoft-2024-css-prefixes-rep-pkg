import { generateSid, STAGING_HOSTS, getTopic, getLanguage } from './common.js';
import { sendEvent } from './sendEvent.js';
const ANON_TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/anon';
const ANON_TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/anon';
const CONTEXT_FREE_TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/cf';
const CONTEXT_FREE_TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/cf';
const ANON_TRACKING_SID = generateSid();
const CONTEXT_FREE_TRACKING_SID = generateSid();
/**
 * Tracker factory function, configure it with a session identifer obtained from `generateSid()`
 * it then returns a function that is initially configured with AnonTrackingConfig and then can be used to track to this
 * tracker
 *
 * @param sid the session identifier for the generated tracker
 * @returns - tracker function
 */
const Tracking = sid => {
  // Monotonically increasing ticker for sent messages.
  // This allows us to detect if messages went missing or arrived out of order
  let seq = 0;
  return config => event => {
    var _config$getSeedPayloa, _config$getLanguage, _config$getLocation, _config$websiteId;
    // e.g. www.page.load
    const topic = getTopic(event, config.logToConsole || false);
    const seedPayload = (config === null || config === void 0 ? void 0 : (_config$getSeedPayloa = config.getSeedPayload) === null || _config$getSeedPayloa === void 0 ? void 0 : _config$getSeedPayloa.call(config)) ?? {};
    const message = {
      language: (config === null || config === void 0 ? void 0 : (_config$getLanguage = config.getLanguage) === null || _config$getLanguage === void 0 ? void 0 : _config$getLanguage.call(config)) ?? getLanguage(),
      location: (config === null || config === void 0 ? void 0 : (_config$getLocation = config.getLocation) === null || _config$getLocation === void 0 ? void 0 : _config$getLocation.call(config)) ?? document.location.href,
      ...seedPayload,
      ...event.payload
    };
    const data = {
      meta: JSON.stringify(message),
      topic,
      seq: seq++,
      sid,
      websiteId: config === null || config === void 0 ? void 0 : (_config$websiteId = config.websiteId) === null || _config$websiteId === void 0 ? void 0 : _config$websiteId.call(config)
    };
    if (config.logToConsole) {
      console.log(`frontend-tracking: anonymous event "${data.topic}" tracked`, message, data);
    }
    const dataJSON = JSON.stringify(data);
    sendEvent(config.endpoint, dataJSON, config === null || config === void 0 ? void 0 : config.sendBeacon);
  };
};
/**
 * Provide a tracking config to get an anonymous tracking tracker.
 *
 * This tracker provides 24h sessionalization based on UA and IP address
 *
 * @remarks
 * Compared to DWH tracking the payload doesn't contain userAccountId or anonId (shd cookie),
 * because with such values we could identify a user
 *
 * Also websiteId though present, is used differently. With DWH tracking websiteId is sent in the CMS when the user is editing the website,
 * in Anon tracking it is the website being tracked.
 *
 * @param config - AnonTrackingConfig (endpoint, websiteId, ... etc.)
 * @returns - tracker function
 */
const AnonTracking = Tracking(ANON_TRACKING_SID);
/**
 * Provide a tracking config to get a context free tracker
 *
 * This tracker does not allow sessionalization beyond a single page view.
 *
 * @remarks
 * Compared to DWH tracking the payload doesn't contain userAccountId or anonId (shd cookie),
 * because with such values we could identify a user
 *
 * Also websiteId though present, is used differently. With DWH tracking websiteId is sent in the CMS when the user is editing the website,
 * in Anon tracking it is the website being tracked.
 *
 * @param config - AnonTrackingConfig (endpoint, websiteId, ... etc.)
 * @returns - tracker function
 */
const ContextFreeTracking = Tracking(CONTEXT_FREE_TRACKING_SID);
/**
 * Gets tracking endpoint URL by hostname for anonymous tracking
 *
 * @remarks
 * Provide a hostname to decide which endpoint to use (staging vs. prod)
 *
 * @param hostname - e.g. window.location
 * @returns - URL of tracking endpoint
 */
function getAnonTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? ANON_TRACKING_ENDPOINT_STAGE : ANON_TRACKING_ENDPOINT_PROD;
}
/**
 * Gets tracking endpoint URL by hostname for Context Free tracking
 *
 * @remarks
 * Provide a hostname to decide which endpoint to use (staging vs. prod)
 *
 * @param hostname - e.g. window.location
 * @returns - URL of tracking endpoint
 */
function getContextFreeTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? CONTEXT_FREE_TRACKING_ENDPOINT_STAGE : CONTEXT_FREE_TRACKING_ENDPOINT_PROD;
}
export { ANON_TRACKING_ENDPOINT_PROD, ANON_TRACKING_ENDPOINT_STAGE, ANON_TRACKING_SID, AnonTracking, CONTEXT_FREE_TRACKING_ENDPOINT_PROD, CONTEXT_FREE_TRACKING_ENDPOINT_STAGE, CONTEXT_FREE_TRACKING_SID, ContextFreeTracking, Tracking, getAnonTrackingEndpoint, getContextFreeTrackingEndpoint };